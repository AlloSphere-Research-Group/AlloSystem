#ifdef SEMASTART
__SEMASTART = DIAG_START_SEMA,
#undef SEMASTART
#endif
DIAG(err_abstract_type_in_decl, CLASS_ERROR, diag::MAP_ERROR, "%select{return|parameter|variable|field}1 type %0 is an abstract class", 0, true)
DIAG(err_addr_of_label_in_protected_scope, CLASS_ERROR, diag::MAP_ERROR, "address taken of label in protected scope, jump to it would have unknown effect on scope", 0, true)
DIAG(err_addr_ovl_ambiguous, CLASS_ERROR, diag::MAP_ERROR, "address of overloaded function %0 is ambiguous", 0, true)
DIAG(err_alignof_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "invalid application of '__alignof' to an incomplete type %0", 0, true)
DIAG(err_allocation_of_abstract_type, CLASS_ERROR, diag::MAP_ERROR, "allocation of an object of abstract type %0", 0, true)
DIAG(err_altivec_empty_initializer, CLASS_ERROR, diag::MAP_ERROR, "expected initializer", 0, true)
DIAG(err_ambiguous_base_to_derived_cast, CLASS_ERROR, diag::MAP_ERROR, "ambiguous cast from base %0 to derived %1:%2", 0, true)
DIAG(err_ambiguous_derived_to_base_conv, CLASS_ERROR, diag::MAP_ERROR, "ambiguous conversion from derived class %0 to base class %1:%2", 0, true)
DIAG(err_ambiguous_member_multiple_subobject_types, CLASS_ERROR, diag::MAP_ERROR, "member %0 found in multiple base classes of different types", 0, true)
DIAG(err_ambiguous_member_multiple_subobjects, CLASS_ERROR, diag::MAP_ERROR, "non-static member %0 found in multiple base-class subobjects of type %1:%2", 0, true)
DIAG(err_ambiguous_memptr_conv, CLASS_ERROR, diag::MAP_ERROR, "ambiguous conversion from pointer to member of %select{base|derived}0 class %1 to pointer to member of %select{derived|base}0 class %2:%3", 0, true)
DIAG(err_ambiguous_reference, CLASS_ERROR, diag::MAP_ERROR, "reference to %0 is ambiguous", 0, true)
DIAG(err_anon_bitfield_has_negative_width, CLASS_ERROR, diag::MAP_ERROR, "anonymous bit-field has negative width (%0)", 0, true)
DIAG(err_anon_bitfield_width_exceeds_type_size, CLASS_ERROR, diag::MAP_ERROR, "size of anonymous bitfield exceeds size of its type (%0 bits)", 0, true)
DIAG(err_anonymous_record_bad_member, CLASS_ERROR, diag::MAP_ERROR, "anonymous %select{struct|union}0 can only contain non-static data members", 0, true)
DIAG(err_anonymous_record_nonpublic_member, CLASS_ERROR, diag::MAP_ERROR, "anonymous %select{struct|union}0 cannot contain a %select{private|protected}1 data member", 0, true)
DIAG(err_anonymous_record_with_function, CLASS_ERROR, diag::MAP_ERROR, "functions cannot be declared in an anonymous %select{struct|union}0", 0, true)
DIAG(err_anonymous_record_with_static, CLASS_ERROR, diag::MAP_ERROR, "static members cannot be declared in an anonymous %select{struct|union}0", 0, true)
DIAG(err_anonymous_record_with_type, CLASS_ERROR, diag::MAP_ERROR, "types cannot be declared in an anonymous %select{struct|union}0", 0, true)
DIAG(err_anonymous_struct_member_redecl, CLASS_ERROR, diag::MAP_ERROR, "member of anonymous struct redeclares %0", 0, true)
DIAG(err_anonymous_struct_not_member, CLASS_ERROR, diag::MAP_ERROR, "anonymous %select{structs|structs and classes}0 must be %select{struct or union|class}0 members", 0, true)
DIAG(err_anonymous_union_member_redecl, CLASS_ERROR, diag::MAP_ERROR, "member of anonymous union redeclares %0", 0, true)
DIAG(err_anonymous_union_not_static, CLASS_ERROR, diag::MAP_ERROR, "anonymous unions at namespace or global scope must be declared 'static'", 0, true)
DIAG(err_anonymous_union_with_storage_spec, CLASS_ERROR, diag::MAP_ERROR, "anonymous union at class scope must not have a storage specifier", 0, true)
DIAG(err_argument_invalid_range, CLASS_ERROR, diag::MAP_ERROR, "argument should be a value from %0 to %1", 0, true)
DIAG(err_arithmetic_nonfragile_interface, CLASS_ERROR, diag::MAP_ERROR, "arithmetic on pointer to interface %0, which is not a constant size in non-fragile ABI", 0, true)
DIAG(err_array_designator_empty_range, CLASS_ERROR, diag::MAP_ERROR, "array designator range [%0, %1] is empty", 0, true)
DIAG(err_array_designator_negative, CLASS_ERROR, diag::MAP_ERROR, "array designator value '%0' is negative", 0, true)
DIAG(err_array_designator_non_array, CLASS_ERROR, diag::MAP_ERROR, "array designator cannot initialize non-array type %0", 0, true)
DIAG(err_array_designator_too_large, CLASS_ERROR, diag::MAP_ERROR, "array designator index (%0) exceeds array bounds (%1)", 0, true)
DIAG(err_array_init_list_required, CLASS_ERROR, diag::MAP_ERROR, "initialization with '{...}' expected for array", 0, true)
DIAG(err_array_new_needs_size, CLASS_ERROR, diag::MAP_ERROR, "array size must be specified in new expressions", 0, true)
DIAG(err_array_size_non_int, CLASS_ERROR, diag::MAP_ERROR, "size of array has non-integer type %0", 0, true)
DIAG(err_array_size_not_integral, CLASS_ERROR, diag::MAP_ERROR, "array size expression must have integral or enumerated type, not %0", 0, true)
DIAG(err_array_star_outside_prototype, CLASS_ERROR, diag::MAP_ERROR, "star modifier used outside of function prototype", 0, true)
DIAG(err_as_qualified_auto_decl, CLASS_ERROR, diag::MAP_ERROR, "automatic variable qualified with an address space", 0, true)
DIAG(err_asm_invalid_input_constraint, CLASS_ERROR, diag::MAP_ERROR, "invalid input constraint '%0' in asm", 0, true)
DIAG(err_asm_invalid_lvalue_in_input, CLASS_ERROR, diag::MAP_ERROR, "invalid lvalue in asm input for constraint '%0'", 0, true)
DIAG(err_asm_invalid_lvalue_in_output, CLASS_ERROR, diag::MAP_ERROR, "invalid lvalue in asm output", 0, true)
DIAG(err_asm_invalid_output_constraint, CLASS_ERROR, diag::MAP_ERROR, "invalid output constraint '%0' in asm", 0, true)
DIAG(err_asm_invalid_type_in_input, CLASS_ERROR, diag::MAP_ERROR, "invalid type %0 in asm input for constraint '%1'", 0, true)
DIAG(err_asm_tying_incompatible_types, CLASS_ERROR, diag::MAP_ERROR, "unsupported inline asm: input with type %0 matching output with type %1", 0, true)
DIAG(err_asm_unknown_register_name, CLASS_ERROR, diag::MAP_ERROR, "unknown register name '%0' in asm", 0, true)
DIAG(err_asm_wide_character, CLASS_ERROR, diag::MAP_ERROR, "wide string is invalid in 'asm'", 0, true)
DIAG(err_at_least_one_initializer_needed_to_size_array, CLASS_ERROR, diag::MAP_ERROR, "at least one initializer value required to size array", 0, true)
DIAG(err_atdef_nonfragile_interface, CLASS_ERROR, diag::MAP_ERROR, "invalid application of @defs in non-fragile ABI", 0, true)
DIAG(err_atomic_builtin_must_be_pointer, CLASS_ERROR, diag::MAP_ERROR, "first argument to atomic builtin must be a pointer (%0 invalid)", 0, true)
DIAG(err_atomic_builtin_must_be_pointer_intptr, CLASS_ERROR, diag::MAP_ERROR, "first argument to atomic builtin must be a pointer to integer or pointer (%0 invalid)", 0, true)
DIAG(err_atomic_builtin_pointer_size, CLASS_ERROR, diag::MAP_ERROR, "first argument to atomic builtin must be a pointer to 1,2,4,8 or 16 byte type (%0 invalid)", 0, true)
DIAG(err_attr_wrong_decl, CLASS_ERROR, diag::MAP_ERROR, "'%0' attribute invalid on this declaration, requires typedef or value", 0, true)
DIAG(err_attribute_address_multiple_qualifiers, CLASS_ERROR, diag::MAP_ERROR, "multiple address spaces specified for type", 0, true)
DIAG(err_attribute_address_space_negative, CLASS_ERROR, diag::MAP_ERROR, "address space is negative", 0, true)
DIAG(err_attribute_address_space_not_int, CLASS_ERROR, diag::MAP_ERROR, "address space attribute requires an integer constant", 0, true)
DIAG(err_attribute_address_space_too_high, CLASS_ERROR, diag::MAP_ERROR, "address space is larger than the maximum supported (%0)", 0, true)
DIAG(err_attribute_aligned_not_power_of_two, CLASS_ERROR, diag::MAP_ERROR, "requested alignment is not a power of 2", 0, true)
DIAG(err_attribute_argument_n_not_int, CLASS_ERROR, diag::MAP_ERROR, "'%0' attribute requires parameter %1 to be an integer constant", 0, true)
DIAG(err_attribute_argument_n_not_string, CLASS_ERROR, diag::MAP_ERROR, "'%0' attribute requires parameter %1 to be a string", 0, true)
DIAG(err_attribute_argument_not_int, CLASS_ERROR, diag::MAP_ERROR, "'%0' attribute requires integer constant", 0, true)
DIAG(err_attribute_argument_out_of_bounds, CLASS_ERROR, diag::MAP_ERROR, "'%0' attribute parameter %1 is out of bounds", 0, true)
DIAG(err_attribute_can_be_applied_only_to_symbol_declaration, CLASS_ERROR, diag::MAP_ERROR, "%0 attribute can be applied only to symbol declaration", 0, true)
DIAG(err_attribute_cleanup_arg_not_found, CLASS_ERROR, diag::MAP_ERROR, "'cleanup' argument %0 not found", 0, true)
DIAG(err_attribute_cleanup_arg_not_function, CLASS_ERROR, diag::MAP_ERROR, "'cleanup' argument %0 is not a function", 0, true)
DIAG(err_attribute_cleanup_func_arg_incompatible_type, CLASS_ERROR, diag::MAP_ERROR, "'cleanup' function %0 parameter has type %1 which is incompatible with type %2", 0, true)
DIAG(err_attribute_cleanup_func_must_take_one_arg, CLASS_ERROR, diag::MAP_ERROR, "'cleanup' function %0 must take 1 parameter", 0, true)
DIAG(err_attribute_iboutlet, CLASS_ERROR, diag::MAP_ERROR, "'iboutlet' attribute can only be applied to instance variables or properties", 0, true)
DIAG(err_attribute_invalid_size, CLASS_ERROR, diag::MAP_ERROR, "vector size not an integral multiple of component size", 0, true)
DIAG(err_attribute_invalid_vector_type, CLASS_ERROR, diag::MAP_ERROR, "invalid vector type %0", 0, true)
DIAG(err_attribute_missing_parameter_name, CLASS_ERROR, diag::MAP_ERROR, "attribute requires unquoted parameter", 0, true)
DIAG(err_attribute_multiple_objc_gc, CLASS_ERROR, diag::MAP_ERROR, "multiple garbage collection attributes specified for type", 0, true)
DIAG(err_attribute_not_string, CLASS_ERROR, diag::MAP_ERROR, "argument to %0 attribute was not a string literal", 0, true)
DIAG(err_attribute_overloadable_missing, CLASS_ERROR, diag::MAP_ERROR, "%select{overloaded function|redeclaration of}0 %1 must have the 'overloadable' attribute", 0, true)
DIAG(err_attribute_overloadable_no_prototype, CLASS_ERROR, diag::MAP_ERROR, "'overloadable' function %0 must have a prototype", 0, true)
DIAG(err_attribute_overloadable_not_function, CLASS_ERROR, diag::MAP_ERROR, "'overloadable' attribute can only be applied to a function", 0, true)
DIAG(err_attribute_regparm_invalid_number, CLASS_ERROR, diag::MAP_ERROR, "'regparm' parameter must be between 0 and %0 inclusive", 0, true)
DIAG(err_attribute_regparm_wrong_platform, CLASS_ERROR, diag::MAP_ERROR, "'regparm' is not valid on this platform", 0, true)
DIAG(err_attribute_requires_objc_interface, CLASS_ERROR, diag::MAP_ERROR, "attribute may only be applied to an Objective-C interface", 0, true)
DIAG(err_attribute_section_invalid_for_target, CLASS_ERROR, diag::MAP_ERROR, "argument to 'section' attribute is not valid for this target: %0", 0, true)
DIAG(err_attribute_sentinel_less_than_zero, CLASS_ERROR, diag::MAP_ERROR, "'sentinel' parameter 1 less than zero", 0, true)
DIAG(err_attribute_sentinel_not_zero_or_one, CLASS_ERROR, diag::MAP_ERROR, "'sentinel' parameter 2 not 0 or 1", 0, true)
DIAG(err_attribute_weak_static, CLASS_ERROR, diag::MAP_ERROR, "weak declaration of '%0' must be public", 0, true)
DIAG(err_attribute_wrong_number_arguments, CLASS_ERROR, diag::MAP_ERROR, "attribute requires %0 argument(s)", 0, true)
DIAG(err_attribute_zero_size, CLASS_ERROR, diag::MAP_ERROR, "zero vector size", 0, true)
DIAG(err_attributes_are_not_compatible, CLASS_ERROR, diag::MAP_ERROR, "%0 and %1 attributes are not compatible", 0, true)
DIAG(err_auto_not_allowed, CLASS_ERROR, diag::MAP_ERROR, "'auto' not allowed in %select{function prototype|struct member|union member|class member|exception declaration|template parameter|block literal}0", 0, true)
DIAG(err_auto_var_requires_init, CLASS_ERROR, diag::MAP_ERROR, "declaration of variable %0 with type %1 requires an initializer", 0, true)
DIAG(err_auto_variable_cannot_appear_in_own_initializer, CLASS_ERROR, diag::MAP_ERROR, "variable %0 declared with 'auto' type cannot appear in its own initializer", 0, true)
DIAG(err_bad_const_cast_dest, CLASS_ERROR, diag::MAP_ERROR, "%select{const_cast||||C-style cast|functional-style cast}0 to %2, which is not a reference, pointer-to-object, or pointer-to-data-member", 0, true)
DIAG(err_bad_cxx_cast_const_away, CLASS_ERROR, diag::MAP_ERROR, "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast}0 from %1 to %2 casts away constness", 0, true)
DIAG(err_bad_cxx_cast_generic, CLASS_ERROR, diag::MAP_ERROR, "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast}0 from %1 to %2 is not allowed", 0, true)
DIAG(err_bad_cxx_cast_rvalue, CLASS_ERROR, diag::MAP_ERROR, "%select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast}0 from rvalue to reference type %2", 0, true)
DIAG(err_bad_dynamic_cast_incomplete, CLASS_ERROR, diag::MAP_ERROR, "%0 is an incomplete type", 0, true)
DIAG(err_bad_dynamic_cast_not_class, CLASS_ERROR, diag::MAP_ERROR, "%0 is not a class", 0, true)
DIAG(err_bad_dynamic_cast_not_polymorphic, CLASS_ERROR, diag::MAP_ERROR, "%0 is not polymorphic", 0, true)
DIAG(err_bad_dynamic_cast_not_ptr, CLASS_ERROR, diag::MAP_ERROR, "%0 is not a pointer", 0, true)
DIAG(err_bad_dynamic_cast_not_ref_or_ptr, CLASS_ERROR, diag::MAP_ERROR, "%0 is not a reference or pointer", 0, true)
DIAG(err_bad_language, CLASS_ERROR, diag::MAP_ERROR, "unknown linkage language", 0, true)
DIAG(err_bad_lvalue_to_rvalue_cast, CLASS_ERROR, diag::MAP_ERROR, "cannot cast from lvalue of type %1 to rvalue reference type %2; types are not compatible", 0, true)
DIAG(err_bad_memptr_lhs, CLASS_ERROR, diag::MAP_ERROR, "left hand operand to %0 must be a %select{|pointer to }1class compatible with the right hand operand, but is %2", 0, true)
DIAG(err_bad_memptr_rhs, CLASS_ERROR, diag::MAP_ERROR, "right hand operand to %0 has non pointer-to-member type %1", 0, true)
DIAG(err_bad_new_type, CLASS_ERROR, diag::MAP_ERROR, "cannot allocate %select{function|reference}1 type %0 with new", 0, true)
DIAG(err_bad_receiver_type, CLASS_ERROR, diag::MAP_ERROR, "bad receiver type %0", 0, true)
DIAG(err_bad_reinterpret_cast_small_int, CLASS_ERROR, diag::MAP_ERROR, "cast from pointer to smaller type %2 loses information", 0, true)
DIAG(err_bad_static_cast_member_pointer_nonmp, CLASS_ERROR, diag::MAP_ERROR, "cannot cast from type %1 to member pointer type %2", 0, true)
DIAG(err_bad_static_cast_pointer_nonpointer, CLASS_ERROR, diag::MAP_ERROR, "cannot cast from type %1 to pointer type %2", 0, true)
DIAG(err_bad_variable_name, CLASS_ERROR, diag::MAP_ERROR, "'%0' cannot be the name of a variable or data member", 0, true)
DIAG(err_base_clause_on_union, CLASS_ERROR, diag::MAP_ERROR, "unions cannot have base classes", 0, true)
DIAG(err_base_init_direct_and_virtual, CLASS_ERROR, diag::MAP_ERROR, "base class initializer %0 names both a direct base class and an inherited virtual base class", 0, true)
DIAG(err_base_init_does_not_name_class, CLASS_ERROR, diag::MAP_ERROR, "constructor initializer %0 does not name a class", 0, true)
DIAG(err_base_must_be_class, CLASS_ERROR, diag::MAP_ERROR, "base specifier must name a class", 0, true)
DIAG(err_bitfield_has_negative_width, CLASS_ERROR, diag::MAP_ERROR, "bit-field %0 has negative width (%1)", 0, true)
DIAG(err_bitfield_has_zero_width, CLASS_ERROR, diag::MAP_ERROR, "named bit-field %0 has zero width", 0, true)
DIAG(err_bitfield_width_exceeds_type_size, CLASS_ERROR, diag::MAP_ERROR, "size of bit-field %0 exceeds size of its type (%1 bits)", 0, true)
DIAG(err_block_decl_ref_not_modifiable_lvalue, CLASS_ERROR, diag::MAP_ERROR, "variable is not assignable (missing __block type specifier)", 0, true)
DIAG(err_block_extern_cant_init, CLASS_ERROR, diag::MAP_ERROR, "'extern' variable cannot have an initializer", 0, true)
DIAG(err_block_on_nonlocal, CLASS_ERROR, diag::MAP_ERROR, "__block attribute not allowed, only allowed on local variables", 0, true)
DIAG(err_block_on_vm, CLASS_ERROR, diag::MAP_ERROR, "__block attribute not allowed on declaration with a variably modified type", 0, true)
DIAG(err_block_return_missing_expr, CLASS_ERROR, diag::MAP_ERROR, "non-void block should return a value", 0, true)
DIAG(err_block_returns_array, CLASS_ERROR, diag::MAP_ERROR, "block declared as returning an array", 0, true)
DIAG(err_block_with_return_type_requires_args, CLASS_ERROR, diag::MAP_ERROR, "block with explicit return type requires argument list", 0, true)
DIAG(err_blocks_disable, CLASS_ERROR, diag::MAP_ERROR, "blocks support disabled - compile with -fblocks or pick a deployment target that supports them", 0, true)
DIAG(err_break_not_in_loop_or_switch, CLASS_ERROR, diag::MAP_ERROR, "'break' statement not in loop or switch statement", 0, true)
DIAG(err_builtin_definition, CLASS_ERROR, diag::MAP_ERROR, "definition of builtin function %0", 0, true)
DIAG(err_builtin_direct_init_more_than_one_arg, CLASS_ERROR, diag::MAP_ERROR, "initializer of a builtin type can only take one argument", 0, true)
DIAG(err_builtin_func_cast_more_than_one_arg, CLASS_ERROR, diag::MAP_ERROR, "function-style cast to a builtin type can only take one argument", 0, true)
DIAG(err_builtin_longjmp_invalid_val, CLASS_ERROR, diag::MAP_ERROR, "argument to __builtin_longjmp must be a constant 1", 0, true)
DIAG(err_call_incomplete_argument, CLASS_ERROR, diag::MAP_ERROR, "argument type %0 is incomplete", 0, true)
DIAG(err_call_incomplete_return, CLASS_ERROR, diag::MAP_ERROR, "return type of called function (%0) is incomplete", 0, true)
DIAG(err_cannot_determine_declared_type_of_overloaded_function, CLASS_ERROR, diag::MAP_ERROR, "can't determine the declared type of an overloaded function", 0, true)
DIAG(err_cannot_form_pointer_to_member_of_reference_type, CLASS_ERROR, diag::MAP_ERROR, "cannot form a pointer-to-member to member %0 of reference type %1", 0, true)
DIAG(err_cannot_initialize_decl, CLASS_ERROR, diag::MAP_ERROR, "cannot initialize %0 with an %select{rvalue|lvalue}1 of type %2", 0, true)
DIAG(err_cannot_initialize_decl_noname, CLASS_ERROR, diag::MAP_ERROR, "cannot initialize a value of type %0 with an %select{rvalue|lvalue}1 of type %2", 0, true)
DIAG(err_cannot_pass_objc_interface_to_vararg, CLASS_ERROR, diag::MAP_ERROR, "cannot pass object with interface type %0 by-value through variadic %select{function|block|method}1", 0, true)
DIAG(err_case_not_in_switch, CLASS_ERROR, diag::MAP_ERROR, "'case' statement not in switch statement", 0, true)
DIAG(err_cast_pointer_from_non_pointer_int, CLASS_ERROR, diag::MAP_ERROR, "operand of type %0 cannot be cast to a pointer type", 0, true)
DIAG(err_cast_pointer_to_non_pointer_int, CLASS_ERROR, diag::MAP_ERROR, "pointer cannot be cast to type %0", 0, true)
DIAG(err_cast_selector_expr, CLASS_ERROR, diag::MAP_ERROR, "cannot type cast @selector expression", 0, true)
DIAG(err_catch_incomplete, CLASS_ERROR, diag::MAP_ERROR, "cannot catch incomplete type %0", 0, true)
DIAG(err_catch_incomplete_ptr, CLASS_ERROR, diag::MAP_ERROR, "cannot catch pointer to incomplete type %0", 0, true)
DIAG(err_catch_incomplete_ref, CLASS_ERROR, diag::MAP_ERROR, "cannot catch reference to incomplete type %0", 0, true)
DIAG(err_catch_param_not_objc_type, CLASS_ERROR, diag::MAP_ERROR, "@catch parameter is not a pointer to an interface type", 0, true)
DIAG(err_catch_rvalue_ref, CLASS_ERROR, diag::MAP_ERROR, "cannot catch exceptions by rvalue reference", 0, true)
DIAG(err_cfstring_literal_not_string_constant, CLASS_ERROR, diag::MAP_ERROR, "CFString literal is not a string constant", 0, true)
DIAG(err_class_redeclared_with_different_access, CLASS_ERROR, diag::MAP_ERROR, "%0 redeclared with '%1' access", 0, true)
DIAG(err_collection_expr_type, CLASS_ERROR, diag::MAP_ERROR, "collection expression type %0 is not a valid object", 0, true)
DIAG(err_conditional_ambiguous, CLASS_ERROR, diag::MAP_ERROR, "conditional expression is ambiguous; %0 can be converted to %1 and vice versa", 0, true)
DIAG(err_conditional_ambiguous_ovl, CLASS_ERROR, diag::MAP_ERROR, "conditional expression is ambiguous; %0 and %1 can be converted to several common types", 0, true)
DIAG(err_conditional_void_nonvoid, CLASS_ERROR, diag::MAP_ERROR, "%select{left|right}1 operand to ? is void, but %select{right|left}1 operand is of type %0", 0, true)
DIAG(err_conflicting_aliasing_type, CLASS_ERROR, diag::MAP_ERROR, "conflicting types for alias %0", 0, true)
DIAG(err_conflicting_ivar_bitwidth, CLASS_ERROR, diag::MAP_ERROR, "instance variable %0 has conflicting bitfield width", 0, true)
DIAG(err_conflicting_ivar_name, CLASS_ERROR, diag::MAP_ERROR, "conflicting instance variable names: %0 vs %1", 0, true)
DIAG(err_conflicting_ivar_type, CLASS_ERROR, diag::MAP_ERROR, "instance variable %0 has conflicting type: %1 vs %2", 0, true)
DIAG(err_conflicting_super_class, CLASS_ERROR, diag::MAP_ERROR, "conflicting super class name %0", 0, true)
DIAG(err_conflicting_types, CLASS_ERROR, diag::MAP_ERROR, "conflicting types for %0", 0, true)
DIAG(err_const_var_requires_init, CLASS_ERROR, diag::MAP_ERROR, "declaration of const variable '%0' requires an initializer", 0, true)
DIAG(err_constructor_byvalue_arg, CLASS_ERROR, diag::MAP_ERROR, "copy constructor must pass its first argument by reference", 0, true)
DIAG(err_constructor_cannot_be, CLASS_ERROR, diag::MAP_ERROR, "constructor cannot be declared '%0'", 0, true)
DIAG(err_constructor_redeclared, CLASS_ERROR, diag::MAP_ERROR, "constructor cannot be redeclared", 0, true)
DIAG(err_constructor_return_type, CLASS_ERROR, diag::MAP_ERROR, "constructor cannot have a return type", 0, true)
DIAG(err_continuation_class, CLASS_ERROR, diag::MAP_ERROR, "continuation class has no primary class", 0, true)
DIAG(err_continue_not_in_loop, CLASS_ERROR, diag::MAP_ERROR, "'continue' statement not in loop statement", 0, true)
DIAG(err_conv_function_not_member, CLASS_ERROR, diag::MAP_ERROR, "conversion function must be a non-static member function", 0, true)
DIAG(err_conv_function_redeclared, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot be redeclared", 0, true)
DIAG(err_conv_function_return_type, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot have a return type", 0, true)
DIAG(err_conv_function_to_array, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot convert to an array type", 0, true)
DIAG(err_conv_function_to_function, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot convert to a function type", 0, true)
DIAG(err_conv_function_variadic, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot be variadic", 0, true)
DIAG(err_conv_function_with_params, CLASS_ERROR, diag::MAP_ERROR, "conversion function cannot have any parameters", 0, true)
DIAG(err_conv_to_inaccessible_base, CLASS_ERROR, diag::MAP_ERROR, "conversion from %0 to inaccessible base class %1", 0, false)
DIAG(err_covariant_return_ambiguous_derived_to_base_conv, CLASS_ERROR, diag::MAP_ERROR, "return type of virtual function %3 is not covariant with the return type of the function it overrides (ambiguous conversion from derived class %0 to base class %1:%2)", 0, true)
DIAG(err_covariant_return_inaccessible_base, CLASS_ERROR, diag::MAP_ERROR, "return type of virtual function %2 is not covariant with the return type of the function it overrides (conversion from %0 to inaccessible base class %1)", 0, false)
DIAG(err_covariant_return_not_derived, CLASS_ERROR, diag::MAP_ERROR, "return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 is not derived from %2)", 0, true)
DIAG(err_covariant_return_type_class_type_more_qualified, CLASS_ERROR, diag::MAP_ERROR, "return type of virtual function %0 is not covariant with the return type of the function it overrides (class type %1 is more qualified than class type %2", 0, true)
DIAG(err_covariant_return_type_different_qualifications, CLASS_ERROR, diag::MAP_ERROR, "return type of virtual function %0 is not covariant with the return type of the function it overrides (%1 has different qualifiers than %2)", 0, true)
DIAG(err_decimal_unsupported, CLASS_ERROR, diag::MAP_ERROR, "GNU decimal type extension not supported", 0, true)
DIAG(err_declarator_need_ident, CLASS_ERROR, diag::MAP_ERROR, "declarator requires an identifier", 0, true)
DIAG(err_decrement_bool, CLASS_ERROR, diag::MAP_ERROR, "cannot decrement expression of type bool", 0, true)
DIAG(err_default_arg_in_partial_spec, CLASS_ERROR, diag::MAP_ERROR, "default template argument in a class template partial specialization", 0, true)
DIAG(err_default_not_in_switch, CLASS_ERROR, diag::MAP_ERROR, "'default' statement not in switch statement", 0, true)
DIAG(err_defining_default_ctor, CLASS_ERROR, diag::MAP_ERROR, "cannot define the implicit default constructor for %0, because %select{base class|member}1 %2 does not have any default constructor", 0, true)
DIAG(err_delete_operand, CLASS_ERROR, diag::MAP_ERROR, "cannot delete expression of type %0", 0, true)
DIAG(err_deleted_decl_not_first, CLASS_ERROR, diag::MAP_ERROR, "deleted definition must be first declaration", 0, true)
DIAG(err_deleted_function_use, CLASS_ERROR, diag::MAP_ERROR, "attempt to use a deleted function", 0, true)
DIAG(err_deleted_non_function, CLASS_ERROR, diag::MAP_ERROR, "only functions can have deleted definitions", 0, true)
DIAG(err_dependent_non_type_arg_in_partial_spec, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument depends on a template parameter of the partial specialization", 0, true)
DIAG(err_dependent_typed_non_type_arg_in_partial_spec, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument specializes a template parameter with dependent type %0", 0, true)
DIAG(err_designator_for_scalar_init, CLASS_ERROR, diag::MAP_ERROR, "designator in initializer for scalar type %0", 0, true)
DIAG(err_designator_into_flexible_array_member, CLASS_ERROR, diag::MAP_ERROR, "designator into flexible array member subobject", 0, true)
DIAG(err_destructor_cannot_be, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot be declared '%0'", 0, true)
DIAG(err_destructor_name, CLASS_ERROR, diag::MAP_ERROR, "expected the class name after '~' to name the enclosing class", 0, true)
DIAG(err_destructor_not_member, CLASS_ERROR, diag::MAP_ERROR, "destructor must be a non-static member function", 0, true)
DIAG(err_destructor_redeclared, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot be redeclared", 0, true)
DIAG(err_destructor_return_type, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot have a return type", 0, true)
DIAG(err_destructor_typedef_name, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot be declared using a typedef %0 of the class name", 0, true)
DIAG(err_destructor_variadic, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot be variadic", 0, true)
DIAG(err_destructor_with_params, CLASS_ERROR, diag::MAP_ERROR, "destructor cannot have any parameters", 0, true)
DIAG(err_different_return_type_for_overriding_virtual_function, CLASS_ERROR, diag::MAP_ERROR, "virtual function %0 has a different return type (%1) than the function it overrides (which has return type %2)", 0, true)
DIAG(err_distant_exception_spec, CLASS_ERROR, diag::MAP_ERROR, "exception specifications are not allowed beyond a single level of indirection", 0, true)
DIAG(err_downcast_from_inaccessible_base, CLASS_ERROR, diag::MAP_ERROR, "cannot cast %1 to %0 due to inaccessible conversion path", 0, true)
DIAG(err_dup_implementation_category, CLASS_ERROR, diag::MAP_ERROR, "reimplementation of category %1 for class %0", 0, true)
DIAG(err_dup_implementation_class, CLASS_ERROR, diag::MAP_ERROR, "reimplementation of class %0", 0, true)
DIAG(err_duplicate_base_class, CLASS_ERROR, diag::MAP_ERROR, "base class %0 specified more than once as a direct base class", 0, true)
DIAG(err_duplicate_case, CLASS_ERROR, diag::MAP_ERROR, "duplicate case value '%0'", 0, true)
DIAG(err_duplicate_class_def, CLASS_ERROR, diag::MAP_ERROR, "duplicate interface definition for class %0", 0, true)
DIAG(err_duplicate_member, CLASS_ERROR, diag::MAP_ERROR, "duplicate member %0", 0, true)
DIAG(err_duplicate_method_decl, CLASS_ERROR, diag::MAP_ERROR, "duplicate declaration of method %0", 0, true)
DIAG(err_early_catch_all, CLASS_ERROR, diag::MAP_ERROR, "catch-all handler must come last", 0, true)
DIAG(err_ellipsis_first_arg, CLASS_ERROR, diag::MAP_ERROR, "ISO C requires a named argument before '...'", 0, true)
DIAG(err_empty_scalar_initializer, CLASS_ERROR, diag::MAP_ERROR, "scalar initializer cannot be empty", 0, true)
DIAG(err_exception_spec_in_typedef, CLASS_ERROR, diag::MAP_ERROR, "exception specifications are not allowed in typedefs", 0, true)
DIAG(err_excess_initializers, CLASS_ERROR, diag::MAP_ERROR, "excess elements in %select{array|vector|scalar|union|struct}0 initializer", 0, true)
DIAG(err_excess_initializers_in_char_array_initializer, CLASS_ERROR, diag::MAP_ERROR, "excess elements in char array initializer", 0, true)
DIAG(err_expected_block_lbrace, CLASS_ERROR, diag::MAP_ERROR, "expected '{' in block literal", 0, true)
DIAG(err_expected_class_or_namespace, CLASS_ERROR, diag::MAP_ERROR, "expected a class or namespace", 0, true)
DIAG(err_explicit_instantiation_duplicate, CLASS_ERROR, diag::MAP_ERROR, "duplicate explicit instantiation of %0", 0, true)
DIAG(err_explicit_instantiation_enum, CLASS_ERROR, diag::MAP_ERROR, "explicit instantiation of enumeration type %0", 0, true)
DIAG(err_explicit_instantiation_nontemplate_type, CLASS_ERROR, diag::MAP_ERROR, "explicit instantiation of non-templated type %0", 0, true)
DIAG(err_explicit_instantiation_out_of_scope, CLASS_ERROR, diag::MAP_ERROR, "explicit instantiation of %0 not in a namespace enclosing %1", 0, true)
DIAG(err_explicit_non_function, CLASS_ERROR, diag::MAP_ERROR, "'explicit' can only appear on non-static member functions", 0, true)
DIAG(err_expr_not_ice, CLASS_ERROR, diag::MAP_ERROR, "expression is not an integer constant expression", 0, true)
DIAG(err_ext_vector_component_exceeds_length, CLASS_ERROR, diag::MAP_ERROR, "vector component access exceeds type %0", 0, true)
DIAG(err_ext_vector_component_name_illegal, CLASS_ERROR, diag::MAP_ERROR, "illegal vector component name '%0'", 0, true)
DIAG(err_ext_vector_component_requires_even, CLASS_ERROR, diag::MAP_ERROR, "vector component access invalid for odd-sized type %0", 0, true)
DIAG(err_falloff_nonvoid_block, CLASS_ERROR, diag::MAP_ERROR, "control reaches end of non-void block", 0, true)
DIAG(err_field_declared_as_function, CLASS_ERROR, diag::MAP_ERROR, "field %0 declared as a function", 0, true)
DIAG(err_field_designator_non_aggr, CLASS_ERROR, diag::MAP_ERROR, "field designator cannot initialize a %select{non-struct, non-union|non-class}0 type %1", 0, true)
DIAG(err_field_designator_nonfield, CLASS_ERROR, diag::MAP_ERROR, "field designator %0 does not refer to a non-static data member", 0, true)
DIAG(err_field_designator_unknown, CLASS_ERROR, diag::MAP_ERROR, "field designator %0 does not refer to any field in type %1", 0, true)
DIAG(err_field_incomplete, CLASS_ERROR, diag::MAP_ERROR, "field has incomplete type %0", 0, true)
DIAG(err_field_instantiates_to_function, CLASS_ERROR, diag::MAP_ERROR, "data member instantiated with function type %0", 0, true)
DIAG(err_first_argument_to_va_arg_not_of_type_va_list, CLASS_ERROR, diag::MAP_ERROR, "first argument to 'va_arg' is of type %0 and not 'va_list'", 0, true)
DIAG(err_flexible_array_empty_struct, CLASS_ERROR, diag::MAP_ERROR, "flexible array %0 not allowed in otherwise empty struct", 0, true)
DIAG(err_flexible_array_init_needs_braces, CLASS_ERROR, diag::MAP_ERROR, "flexible array requires brace-enclosed initializer", 0, true)
DIAG(err_flexible_array_init_nonempty, CLASS_ERROR, diag::MAP_ERROR, "non-empty initialization of flexible array member inside subobject", 0, true)
DIAG(err_format_attribute_not, CLASS_ERROR, diag::MAP_ERROR, "format argument not %0", 0, true)
DIAG(err_format_attribute_requires_variadic, CLASS_ERROR, diag::MAP_ERROR, "format attribute requires variadic function", 0, true)
DIAG(err_format_attribute_result_not, CLASS_ERROR, diag::MAP_ERROR, "function does not return %0", 0, true)
DIAG(err_format_strftime_third_parameter, CLASS_ERROR, diag::MAP_ERROR, "strftime format attribute requires 3rd parameter to be 0", 0, true)
DIAG(err_forward_ref_enum, CLASS_ERROR, diag::MAP_ERROR, "ISO C++ forbids forward references to 'enum' types", 0, true)
DIAG(err_friend_decl_defines_class, CLASS_ERROR, diag::MAP_ERROR, "cannot define a type in a friend declaration", 0, true)
DIAG(err_friend_is_member, CLASS_ERROR, diag::MAP_ERROR, "friends cannot be members of the declaring class", 0, true)
DIAG(err_func_def_incomplete_result, CLASS_ERROR, diag::MAP_ERROR, "incomplete result type %0 in function definition", 0, true)
DIAG(err_func_returning_array_function, CLASS_ERROR, diag::MAP_ERROR, "function cannot return array or function type %0", 0, true)
DIAG(err_goto_in_block, CLASS_ERROR, diag::MAP_ERROR, "goto not allowed in block literal", 0, true)
DIAG(err_goto_into_protected_scope, CLASS_ERROR, diag::MAP_ERROR, "illegal goto into protected scope", 0, true)
DIAG(err_ident_list_in_fn_declaration, CLASS_ERROR, diag::MAP_ERROR, "a parameter list without types is only allowed in a function definition", 0, true)
DIAG(err_illegal_decl_array_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "array has incomplete element type %0", 0, true)
DIAG(err_illegal_decl_array_of_auto, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as array of 'auto'", 0, true)
DIAG(err_illegal_decl_array_of_functions, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as array of functions", 0, true)
DIAG(err_illegal_decl_array_of_references, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as array of references", 0, true)
DIAG(err_illegal_decl_mempointer_in_nonclass, CLASS_ERROR, diag::MAP_ERROR, "'%0' does not point into a class", 0, true)
DIAG(err_illegal_decl_mempointer_to_reference, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as a member pointer to a reference", 0, true)
DIAG(err_illegal_decl_mempointer_to_void, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as a member pointer to void", 0, true)
DIAG(err_illegal_decl_pointer_to_reference, CLASS_ERROR, diag::MAP_ERROR, "'%0' declared as a pointer to a reference", 0, true)
DIAG(err_illegal_initializer, CLASS_ERROR, diag::MAP_ERROR, "illegal initializer (only variables can be initialized)", 0, true)
DIAG(err_illegal_initializer_type, CLASS_ERROR, diag::MAP_ERROR, "illegal initializer type %0", 0, true)
DIAG(err_illegal_qualifiers_on_catch_parm, CLASS_ERROR, diag::MAP_ERROR, "illegal qualifiers on @catch parameter", 0, true)
DIAG(err_illegal_super_cast, CLASS_ERROR, diag::MAP_ERROR, "cannot cast 'super' (it isn't an expression)", 0, true)
DIAG(err_illegal_union_member, CLASS_ERROR, diag::MAP_ERROR, "union member %0 has a non-trivial %select{constructor|copy constructor|copy assignment operator|destructor}1", 0, true)
DIAG(err_implicit_decl_requires_setjmp, CLASS_ERROR, diag::MAP_ERROR, "implicit declaration of '%0' requires inclusion of the header <setjmp.h>", 0, true)
DIAG(err_implicit_decl_requires_stdio, CLASS_ERROR, diag::MAP_ERROR, "implicit declaration of '%0' requires inclusion of the header <stdio.h>", 0, true)
DIAG(err_implicit_empty_initializer, CLASS_ERROR, diag::MAP_ERROR, "initializer for aggregate with no elements requires explicit braces", 0, true)
DIAG(err_implicit_instantiate_member_undefined, CLASS_ERROR, diag::MAP_ERROR, "implicit instantiation of undefined member %0", 0, true)
DIAG(err_implicit_object_parameter_init, CLASS_ERROR, diag::MAP_ERROR, "cannot initialize object parameter of type %0 with an expression of type %1", 0, true)
DIAG(err_implicit_pointer_address_space_cast, CLASS_ERROR, diag::MAP_ERROR, "illegal implicit cast between two pointers with different address spaces", 0, true)
DIAG(err_in_class_initializer_non_constant, CLASS_ERROR, diag::MAP_ERROR, "in-class initializer is not an integral constant expression", 0, true)
DIAG(err_in_class_initializer_non_integral_type, CLASS_ERROR, diag::MAP_ERROR, "in-class initializer has non-integral, non-enumeration type %0", 0, true)
DIAG(err_incomplete_base_class, CLASS_ERROR, diag::MAP_ERROR, "base class has incomplete type", 0, true)
DIAG(err_incomplete_in_exception_spec, CLASS_ERROR, diag::MAP_ERROR, "%select{|pointer to |reference to }1incomplete type %0 is not allowed in exception specification", 0, true)
DIAG(err_incomplete_nested_name_spec, CLASS_ERROR, diag::MAP_ERROR, "incomplete type %0 named in nested name specifier", 0, true)
DIAG(err_incomplete_type_used_in_type_trait_expr, CLASS_ERROR, diag::MAP_ERROR, "incomplete type %0 used in type trait expression", 0, true)
DIAG(err_inconsistant_ivar_count, CLASS_ERROR, diag::MAP_ERROR, "inconsistent number of instance variables specified", 0, true)
DIAG(err_indirect_goto_in_protected_scope, CLASS_ERROR, diag::MAP_ERROR, "illegal indirect goto in protected scope, unknown effect on scopes", 0, true)
DIAG(err_init_element_not_constant, CLASS_ERROR, diag::MAP_ERROR, "initializer element is not a compile-time constant", 0, true)
DIAG(err_init_non_aggr_init_list, CLASS_ERROR, diag::MAP_ERROR, "initialization of non-aggregate type %0 with an initializer list", 0, true)
DIAG(err_init_reference_member_uninitialized, CLASS_ERROR, diag::MAP_ERROR, "reference member of type %0 uninitialized", 0, true)
DIAG(err_inline_non_function, CLASS_ERROR, diag::MAP_ERROR, "'inline' can only appear on functions", 0, true)
DIAG(err_int_to_block_pointer, CLASS_ERROR, diag::MAP_ERROR, "invalid conversion %2 integer %1, expected block pointer %0", 0, true)
DIAG(err_introducing_special_friend, CLASS_ERROR, diag::MAP_ERROR, "must use a qualified name when declaring a %select{constructor|destructor|conversion operator}0 as a friend", 0, true)
DIAG(err_invalid_asm_cast_lvalue, CLASS_ERROR, diag::MAP_ERROR, "invalid use of a cast in a inline asm context requiring an l-value: remove the cast or build with -fheinous-gnu-extensions", 0, true)
DIAG(err_invalid_conversion_between_ext_vectors, CLASS_ERROR, diag::MAP_ERROR, "invalid conversion between ext-vector type %0 and %1", 0, true)
DIAG(err_invalid_conversion_between_vector_and_integer, CLASS_ERROR, diag::MAP_ERROR, "invalid conversion between vector type %0 and integer type %1 of different size", 0, true)
DIAG(err_invalid_conversion_between_vector_and_scalar, CLASS_ERROR, diag::MAP_ERROR, "invalid conversion between vector type %0 and scalar type %1", 0, true)
DIAG(err_invalid_conversion_between_vectors, CLASS_ERROR, diag::MAP_ERROR, "invalid conversion between vector type %0 and %1 of different size", 0, true)
DIAG(err_invalid_declarator_global_scope, CLASS_ERROR, diag::MAP_ERROR, "definition or redeclaration of %0 cannot name the global scope", 0, true)
DIAG(err_invalid_declarator_in_function, CLASS_ERROR, diag::MAP_ERROR, "definition or redeclaration of %0 not allowed inside a function", 0, true)
DIAG(err_invalid_declarator_scope, CLASS_ERROR, diag::MAP_ERROR, "definition or redeclaration of %0 not in a namespace enclosing %1", 0, true)
DIAG(err_invalid_incomplete_type_use, CLASS_ERROR, diag::MAP_ERROR, "invalid use of incomplete type %0", 0, true)
DIAG(err_invalid_member_use_in_static_method, CLASS_ERROR, diag::MAP_ERROR, "invalid use of member %0 in static member function", 0, true)
DIAG(err_invalid_non_static_member_use, CLASS_ERROR, diag::MAP_ERROR, "invalid use of nonstatic data member %0", 0, true)
DIAG(err_invalid_protocol_qualifiers, CLASS_ERROR, diag::MAP_ERROR, "invalid protocol qualifiers on non-ObjC type", 0, true)
DIAG(err_invalid_qualified_constructor, CLASS_ERROR, diag::MAP_ERROR, "'%0' qualifier is not allowed on a constructor", 0, true)
DIAG(err_invalid_qualified_destructor, CLASS_ERROR, diag::MAP_ERROR, "'%0' qualifier is not allowed on a destructor", 0, true)
DIAG(err_invalid_qualified_function_type, CLASS_ERROR, diag::MAP_ERROR, "type qualifier is not allowed on this function", 0, true)
DIAG(err_invalid_qualified_typedef_function_type_use, CLASS_ERROR, diag::MAP_ERROR, "a qualified function type cannot be used to declare a nonmember function or a static member function", 0, true)
DIAG(err_invalid_receiver_to_message, CLASS_ERROR, diag::MAP_ERROR, "invalid receiver to message expression", 0, true)
DIAG(err_invalid_this_use, CLASS_ERROR, diag::MAP_ERROR, "invalid use of 'this' outside of a nonstatic member function", 0, true)
DIAG(err_invalid_thread, CLASS_ERROR, diag::MAP_ERROR, "'__thread' is only allowed on variable declarations", 0, true)
DIAG(err_invalid_use_of_array_type, CLASS_ERROR, diag::MAP_ERROR, "an array type is not allowed here", 0, true)
DIAG(err_invalid_use_of_function_type, CLASS_ERROR, diag::MAP_ERROR, "a function type is not allowed here", 0, true)
DIAG(err_lvalue_to_rvalue_ref, CLASS_ERROR, diag::MAP_ERROR, "rvalue reference cannot bind to lvalue", 0, true)
DIAG(err_main_arg_wrong, CLASS_ERROR, diag::MAP_ERROR, "%select{first|second|third}0 argument of 'main' should be of type %1", 0, true)
DIAG(err_main_returns_nonint, CLASS_ERROR, diag::MAP_ERROR, "'main' must return 'int'", 0, true)
DIAG(err_main_surplus_args, CLASS_ERROR, diag::MAP_ERROR, "%0 is too many arguments for 'main': must be 0, 2, or 3", 0, true)
DIAG(err_many_braces_around_scalar_init, CLASS_ERROR, diag::MAP_ERROR, "too many braces around scalar initializer", 0, true)
DIAG(err_maybe_falloff_nonvoid_block, CLASS_ERROR, diag::MAP_ERROR, "control may reach end of non-void block", 0, true)
DIAG(err_mem_init_not_member_or_class, CLASS_ERROR, diag::MAP_ERROR, "member initializer %0 does not name a non-static data member or base class", 0, true)
DIAG(err_mem_initializer_mismatch, CLASS_ERROR, diag::MAP_ERROR, "Too many arguments for member initializer %0", 0, true)
DIAG(err_member_call_without_object, CLASS_ERROR, diag::MAP_ERROR, "call to non-static member function without an object argument", 0, true)
DIAG(err_member_def_does_not_match, CLASS_ERROR, diag::MAP_ERROR, "out-of-line definition does not match any declaration in %0", 0, true)
DIAG(err_member_function_initialization, CLASS_ERROR, diag::MAP_ERROR, "initializer on function does not look like a pure-specifier", 0, true)
DIAG(err_member_initialization, CLASS_ERROR, diag::MAP_ERROR, "%0 can only be initialized if it is a static const integral data member", 0, true)
DIAG(err_member_redeclared, CLASS_ERROR, diag::MAP_ERROR, "class member cannot be redeclared", 0, true)
DIAG(err_mempointer_in_nonclass_type, CLASS_ERROR, diag::MAP_ERROR, "member pointer refers into non-class type %0", 0, true)
DIAG(err_memptr_conv_via_virtual, CLASS_ERROR, diag::MAP_ERROR, "conversion from pointer to member of class %0 to pointer to member of class %1 via virtual base %2 is not allowed", 0, true)
DIAG(err_mismatched_exception_spec, CLASS_ERROR, diag::MAP_ERROR, "exception specification in declaration does not match previous declaration", 0, true)
DIAG(err_missing_default_constructor, CLASS_ERROR, diag::MAP_ERROR, "default constructor for %1 is missing in initialization of %select{base class|member}0", 0, true)
DIAG(err_missing_param_declspec, CLASS_ERROR, diag::MAP_ERROR, "parameter requires a declaration specifier", 0, true)
DIAG(err_missing_type_specifier, CLASS_ERROR, diag::MAP_ERROR, "C++ requires a type specifier for all declarations", 0, true)
DIAG(err_mode_not_primitive, CLASS_ERROR, diag::MAP_ERROR, "mode attribute only supported for integer and floating-point types", 0, true)
DIAG(err_mode_wrong_type, CLASS_ERROR, diag::MAP_ERROR, "type of machine mode does not match type of base type", 0, true)
DIAG(err_multiple_default_labels_defined, CLASS_ERROR, diag::MAP_ERROR, "multiple default labels in one switch", 0, true)
DIAG(err_mutable_const, CLASS_ERROR, diag::MAP_ERROR, "'mutable' and 'const' cannot be mixed", 0, true)
DIAG(err_mutable_function, CLASS_ERROR, diag::MAP_ERROR, "'mutable' cannot be applied to functions", 0, true)
DIAG(err_mutable_nonmember, CLASS_ERROR, diag::MAP_ERROR, "'mutable' can only be applied to member variables", 0, true)
DIAG(err_mutable_reference, CLASS_ERROR, diag::MAP_ERROR, "'mutable' cannot be applied to references", 0, true)
DIAG(err_need_header_before_typeid, CLASS_ERROR, diag::MAP_ERROR, "you need to include <typeinfo> before using the 'typeid' operator", 0, true)
DIAG(err_nested_name_spec_non_tag, CLASS_ERROR, diag::MAP_ERROR, "type %0 cannot be used prior to '::' because it has no members", 0, true)
DIAG(err_nested_redefinition, CLASS_ERROR, diag::MAP_ERROR, "nested redefinition of %0", 0, true)
DIAG(err_new_array_nonconst, CLASS_ERROR, diag::MAP_ERROR, "only the first dimension of an allocated array may be non-const", 0, true)
DIAG(err_new_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "allocation of incomplete type %0", 0, true)
DIAG(err_new_uninitialized_const, CLASS_ERROR, diag::MAP_ERROR, "must provide an initializer if the allocated object is 'const'", 0, true)
DIAG(err_non_static_static, CLASS_ERROR, diag::MAP_ERROR, "non-static declaration of %0 follows static declaration", 0, true)
DIAG(err_non_thread_thread, CLASS_ERROR, diag::MAP_ERROR, "non-thread-local declaration of %0 follows thread-local declaration", 0, true)
DIAG(err_non_variable_decl_in_for, CLASS_ERROR, diag::MAP_ERROR, "declaration of non-local variable in 'for' loop", 0, true)
DIAG(err_non_virtual_pure, CLASS_ERROR, diag::MAP_ERROR, "%0 is not virtual and cannot be declared pure", 0, true)
DIAG(err_nonfunction_block_type, CLASS_ERROR, diag::MAP_ERROR, "block pointer to non-function type is invalid", 0, true)
DIAG(err_nonnull_pointers_only, CLASS_ERROR, diag::MAP_ERROR, "nonnull attribute only applies to pointer arguments", 0, true)
DIAG(err_nonstatic_member_out_of_line, CLASS_ERROR, diag::MAP_ERROR, "non-static data member defined out-of-line", 0, true)
DIAG(err_noreturn_block_has_return_expr, CLASS_ERROR, diag::MAP_ERROR, "block declared 'noreturn' should not return", 0, true)
DIAG(err_not_direct_base_or_virtual, CLASS_ERROR, diag::MAP_ERROR, "type %0 is not a direct or virtual base of '%1'", 0, true)
DIAG(err_not_integral_type_anon_bitfield, CLASS_ERROR, diag::MAP_ERROR, "anonymous bit-field has non-integral type %0", 0, true)
DIAG(err_not_integral_type_bitfield, CLASS_ERROR, diag::MAP_ERROR, "bit-field %0 has non-integral type %1", 0, true)
DIAG(err_not_reference_to_const_init, CLASS_ERROR, diag::MAP_ERROR, "non-const lvalue reference to type %0 cannot be initialized with a %1 of type %2", 0, true)
DIAG(err_not_tag_in_scope, CLASS_ERROR, diag::MAP_ERROR, "%0 does not name a tag member in the specified scope", 0, true)
DIAG(err_nsobject_attribute, CLASS_ERROR, diag::MAP_ERROR, "__attribute ((NSObject)) is for pointer types only", 0, true)
DIAG(err_objc_array_of_interfaces, CLASS_ERROR, diag::MAP_ERROR, "array of interface %0 is invalid (probably should be an array of pointers)", 0, true)
DIAG(err_objc_decls_may_only_appear_in_global_scope, CLASS_ERROR, diag::MAP_ERROR, "Objective-C declarations may only appear in global scope", 0, true)
DIAG(err_objc_property_attr_mutually_exclusive, CLASS_ERROR, diag::MAP_ERROR, "property attributes '%0' and '%1' are mutually exclusive", 0, true)
DIAG(err_objc_property_requires_object, CLASS_ERROR, diag::MAP_ERROR, "property with '%0' attribute must be of object type", 0, true)
DIAG(err_objc_var_decl_inclass, CLASS_ERROR, diag::MAP_ERROR, "cannot declare variable inside @interface or @protocol", 0, true)
DIAG(err_object_cannot_be_passed_returned_by_value, CLASS_ERROR, diag::MAP_ERROR, "interface type %1 cannot be %select{returned|passed}0 by value", 0, true)
DIAG(err_object_size_invalid_argument, CLASS_ERROR, diag::MAP_ERROR, "argument to __builtin_object_size must be a constant integer", 0, true)
DIAG(err_offsetof_array_type, CLASS_ERROR, diag::MAP_ERROR, "offsetof requires array type, %0 invalid", 0, true)
DIAG(err_offsetof_record_type, CLASS_ERROR, diag::MAP_ERROR, "offsetof requires struct, union, or class type, %0 invalid", 0, true)
DIAG(err_only_constructors_take_base_inits, CLASS_ERROR, diag::MAP_ERROR, "only constructors take base initializers", 0, true)
DIAG(err_operator_overload_default_arg, CLASS_ERROR, diag::MAP_ERROR, "parameter of overloaded %0 cannot have a default argument", 0, true)
DIAG(err_operator_overload_must_be, CLASS_ERROR, diag::MAP_ERROR, "overloaded %0 must be a %select{unary|binary|unary or binary}2 operator (has %1 parameter%s1)", 0, true)
DIAG(err_operator_overload_must_be_member, CLASS_ERROR, diag::MAP_ERROR, "overloaded %0 must be a non-static member function", 0, true)
DIAG(err_operator_overload_needs_class_or_enum, CLASS_ERROR, diag::MAP_ERROR, "overloaded %0 must have at least one parameter of class or enumeration type", 0, true)
DIAG(err_operator_overload_post_incdec_must_be_int, CLASS_ERROR, diag::MAP_ERROR, "parameter of overloaded post-%select{increment|decrement}1 operator must have type 'int' (not %0)", 0, true)
DIAG(err_operator_overload_static, CLASS_ERROR, diag::MAP_ERROR, "overloaded %0 cannot be a static member function", 0, true)
DIAG(err_operator_overload_variadic, CLASS_ERROR, diag::MAP_ERROR, "overloaded %0 cannot be variadic", 0, true)
DIAG(err_out_of_line_declaration, CLASS_ERROR, diag::MAP_ERROR, "out-of-line declaration of a member must be a definition", 0, true)
DIAG(err_overload_expr_requires_non_zero_constant, CLASS_ERROR, diag::MAP_ERROR, "overload requires a non-zero constant expression as first argument", 0, true)
DIAG(err_overload_incorrect_fntype, CLASS_ERROR, diag::MAP_ERROR, "argument is not a function, or has wrong number of parameters", 0, true)
DIAG(err_overload_multiple_match, CLASS_ERROR, diag::MAP_ERROR, "more than one matching function found in __builtin_overload", 0, true)
DIAG(err_overload_no_match, CLASS_ERROR, diag::MAP_ERROR, "no matching overload found for arguments of type '%0'", 0, true)
DIAG(err_override_exception_spec, CLASS_ERROR, diag::MAP_ERROR, "exception specification of overriding function is more lax than base version", 0, true)
DIAG(err_ovl_ambiguous_call, CLASS_ERROR, diag::MAP_ERROR, "call to %0 is ambiguous", 0, true)
DIAG(err_ovl_ambiguous_init, CLASS_ERROR, diag::MAP_ERROR, "call to constructor of %0 is ambiguous", 0, true)
DIAG(err_ovl_ambiguous_member_call, CLASS_ERROR, diag::MAP_ERROR, "call to member function %0 is ambiguous", 0, true)
DIAG(err_ovl_ambiguous_object_call, CLASS_ERROR, diag::MAP_ERROR, "call to object of type %0 is ambiguous", 0, true)
DIAG(err_ovl_ambiguous_oper, CLASS_ERROR, diag::MAP_ERROR, "use of overloaded operator '%0' is ambiguous", 0, true)
DIAG(err_ovl_builtin_candidate, CLASS_NOTE, diag::MAP_FATAL, "built-in candidate function %0", 0, true)
DIAG(err_ovl_candidate, CLASS_NOTE, diag::MAP_FATAL, "candidate function", 0, true)
DIAG(err_ovl_candidate_deleted, CLASS_NOTE, diag::MAP_FATAL, "candidate function has been explicitly %select{made unavailable|deleted}0", 0, true)
DIAG(err_ovl_deleted_call, CLASS_ERROR, diag::MAP_ERROR, "call to %select{unavailable|deleted}0 function %1", 0, true)
DIAG(err_ovl_deleted_init, CLASS_ERROR, diag::MAP_ERROR, "call to %select{unavailable|deleted}0 constructor of %1", 0, true)
DIAG(err_ovl_deleted_member_call, CLASS_ERROR, diag::MAP_ERROR, "call to %select{unavailable|deleted}0 member function %1", 0, true)
DIAG(err_ovl_deleted_object_call, CLASS_ERROR, diag::MAP_ERROR, "call to %select{unavailable|deleted}0 function call operator in type %1", 0, true)
DIAG(err_ovl_deleted_oper, CLASS_ERROR, diag::MAP_ERROR, "overload resolution selected %select{unavailable|deleted}0 operator '%1'", 0, true)
DIAG(err_ovl_diff_return_type, CLASS_ERROR, diag::MAP_ERROR, "functions that differ only in their return type cannot be overloaded", 0, true)
DIAG(err_ovl_no_viable_function_in_call, CLASS_ERROR, diag::MAP_ERROR, "no matching function for call to %0", 0, true)
DIAG(err_ovl_no_viable_function_in_init, CLASS_ERROR, diag::MAP_ERROR, "no matching constructor for initialization of %0", 0, true)
DIAG(err_ovl_no_viable_member_function_in_call, CLASS_ERROR, diag::MAP_ERROR, "no matching member function for call to %0", 0, true)
DIAG(err_ovl_no_viable_object_call, CLASS_ERROR, diag::MAP_ERROR, "no matching function for call to object of type %0", 0, true)
DIAG(err_ovl_no_viable_oper, CLASS_ERROR, diag::MAP_ERROR, "no viable overloaded '%0'", 0, true)
DIAG(err_ovl_static_nonstatic_member, CLASS_ERROR, diag::MAP_ERROR, "static and non-static member functions with the same parameter types cannot be overloaded", 0, true)
DIAG(err_ovl_surrogate_cand, CLASS_NOTE, diag::MAP_FATAL, "conversion candidate of type %0", 0, true)
DIAG(err_param_default_argument, CLASS_ERROR, diag::MAP_ERROR, "C does not support default arguments", 0, true)
DIAG(err_param_default_argument_missing, CLASS_ERROR, diag::MAP_ERROR, "missing default argument on parameter", 0, true)
DIAG(err_param_default_argument_missing_name, CLASS_ERROR, diag::MAP_ERROR, "missing default argument on parameter %0", 0, true)
DIAG(err_param_default_argument_nonfunc, CLASS_ERROR, diag::MAP_ERROR, "default arguments can only be specified for parameters in a function declaration", 0, true)
DIAG(err_param_default_argument_redefinition, CLASS_ERROR, diag::MAP_ERROR, "redefinition of default argument", 0, true)
DIAG(err_param_default_argument_references_local, CLASS_ERROR, diag::MAP_ERROR, "default argument references local variable %0 of enclosing function", 0, true)
DIAG(err_param_default_argument_references_param, CLASS_ERROR, diag::MAP_ERROR, "default argument references parameter %0", 0, true)
DIAG(err_param_default_argument_references_this, CLASS_ERROR, diag::MAP_ERROR, "default argument references 'this'", 0, true)
DIAG(err_param_typedef_of_void, CLASS_ERROR, diag::MAP_ERROR, "empty parameter list defined with a typedef of 'void' not allowed in C++", 0, true)
DIAG(err_param_with_void_type, CLASS_ERROR, diag::MAP_ERROR, "argument may not have 'void' type", 0, true)
DIAG(err_parameter_name_omitted, CLASS_ERROR, diag::MAP_ERROR, "parameter name omitted", 0, true)
DIAG(err_partial_spec_args_match_primary_template, CLASS_ERROR, diag::MAP_ERROR, "class template partial specialization does not specialize any template argument; to %select{declare|define}0 the primary template, remove the template argument list", 0, true)
DIAG(err_prefetch_invalid_argument, CLASS_ERROR, diag::MAP_ERROR, "argument to __builtin_prefetch must be a constant integer", 0, true)
DIAG(err_property_not_found, CLASS_ERROR, diag::MAP_ERROR, "property %0 not found on object of type %1", 0, true)
DIAG(err_property_type, CLASS_ERROR, diag::MAP_ERROR, "property cannot have array or function type %0", 0, true)
DIAG(err_protocol_has_circular_dependency, CLASS_ERROR, diag::MAP_ERROR, "protocol has circular dependency", 0, true)
DIAG(err_qualified_block_pointer_type, CLASS_ERROR, diag::MAP_ERROR, "qualifier specification on block pointer type not allowed", 0, true)
DIAG(err_qualified_catch_declarator, CLASS_ERROR, diag::MAP_ERROR, "exception declarator cannot be qualified", 0, true)
DIAG(err_qualified_friend_not_found, CLASS_ERROR, diag::MAP_ERROR, "no function named %0 with type %1 was found in the specified scope", 0, true)
DIAG(err_qualified_param_declarator, CLASS_ERROR, diag::MAP_ERROR, "parameter declarator cannot be qualified", 0, true)
DIAG(err_qualified_typedef_declarator, CLASS_ERROR, diag::MAP_ERROR, "typedef declarator cannot be qualified", 0, true)
DIAG(err_realimag_invalid_type, CLASS_ERROR, diag::MAP_ERROR, "invalid type %0 to %1 operator", 0, true)
DIAG(err_recursive_superclass, CLASS_ERROR, diag::MAP_ERROR, "trying to recursively use %0 as superclass of %1", 0, true)
DIAG(err_redefinition, CLASS_ERROR, diag::MAP_ERROR, "redefinition of %0", 0, true)
DIAG(err_redefinition_different_kind, CLASS_ERROR, diag::MAP_ERROR, "redefinition of %0 as different kind of symbol", 0, true)
DIAG(err_redefinition_different_type, CLASS_ERROR, diag::MAP_ERROR, "redefinition of %0 with a different type", 0, true)
DIAG(err_redefinition_different_typedef, CLASS_ERROR, diag::MAP_ERROR, "typedef redefinition with different types (%0 vs %1)", 0, true)
DIAG(err_redefinition_of_enumerator, CLASS_ERROR, diag::MAP_ERROR, "redefinition of enumerator %0", 0, true)
DIAG(err_redefinition_of_label, CLASS_ERROR, diag::MAP_ERROR, "redefinition of label '%0'", 0, true)
DIAG(err_reference_init_drops_quals, CLASS_ERROR, diag::MAP_ERROR, "initialization of reference to type %0 with a %1 of type %2 drops qualifiers", 0, true)
DIAG(err_reference_to_local_var_in_enclosing_function, CLASS_ERROR, diag::MAP_ERROR, "reference to local variable %0 declared in enclosed function %1", 0, true)
DIAG(err_reference_to_void, CLASS_ERROR, diag::MAP_ERROR, "cannot form a reference to 'void'", 0, true)
DIAG(err_reference_var_requires_init, CLASS_ERROR, diag::MAP_ERROR, "declaration of reference variable %0 requires an initializer", 0, true)
DIAG(err_ret_local_block, CLASS_ERROR, diag::MAP_ERROR, "returning block that lives on the local stack", 0, true)
DIAG(err_return_block_has_expr, CLASS_ERROR, diag::MAP_ERROR, "void block should not return a value", 0, true)
DIAG(err_return_in_block_expression, CLASS_ERROR, diag::MAP_ERROR, "return not allowed in block expression literal", 0, true)
DIAG(err_return_in_constructor_handler, CLASS_ERROR, diag::MAP_ERROR, "return in the catch of a function try block of a constructor is illegal", 0, true)
DIAG(err_selector_element_not_lvalue, CLASS_ERROR, diag::MAP_ERROR, "selector element is not a valid lvalue", 0, true)
DIAG(err_selector_element_type, CLASS_ERROR, diag::MAP_ERROR, "selector element type %0 is not a valid object", 0, true)
DIAG(err_setter_type_void, CLASS_ERROR, diag::MAP_ERROR, "type of setter must be void", 0, true)
DIAG(err_shufflevector_argument_too_large, CLASS_ERROR, diag::MAP_ERROR, "index for __builtin_shufflevector must be less than the total number of vector elements", 0, true)
DIAG(err_shufflevector_incompatible_vector, CLASS_ERROR, diag::MAP_ERROR, "first two arguments to __builtin_shufflevector must have the same type", 0, true)
DIAG(err_shufflevector_non_vector, CLASS_ERROR, diag::MAP_ERROR, "first two arguments to __builtin_shufflevector must be vectors", 0, true)
DIAG(err_shufflevector_nonconstant_argument, CLASS_ERROR, diag::MAP_ERROR, "index for __builtin_shufflevector must be a constant integer", 0, true)
DIAG(err_sizeof_alignof_bitfield, CLASS_ERROR, diag::MAP_ERROR, "invalid application of '%select{sizeof|__alignof}0' to bitfield", 0, true)
DIAG(err_sizeof_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "invalid application of 'sizeof' to an incomplete type %0", 0, true)
DIAG(err_sizeof_nonfragile_interface, CLASS_ERROR, diag::MAP_ERROR, "invalid application of '%select{alignof|sizeof}1' to interface %0 in non-fragile ABI", 0, true)
DIAG(err_stack_const_level, CLASS_ERROR, diag::MAP_ERROR, "level argument for a stack address builtin must be constant", 0, true)
DIAG(err_static_assert_expression_is_not_constant, CLASS_ERROR, diag::MAP_ERROR, "static_assert expression is not an integral constant expression", 0, true)
DIAG(err_static_assert_failed, CLASS_ERROR, diag::MAP_ERROR, "static_assert failed \"%0\"", 0, true)
DIAG(err_static_block_func, CLASS_ERROR, diag::MAP_ERROR, "function declared in block scope cannot have 'static' storage class", 0, true)
DIAG(err_static_data_member_not_allowed_in_local_class, CLASS_ERROR, diag::MAP_ERROR, "static data member %0 not allowed in local class %1", 0, true)
DIAG(err_static_downcast_via_virtual, CLASS_ERROR, diag::MAP_ERROR, "cannot cast %0 to %1 via virtual base %2", 0, true)
DIAG(err_static_illegal_in_new, CLASS_ERROR, diag::MAP_ERROR, "the 'static' modifier for the array size is not legal in new expressions", 0, true)
DIAG(err_static_non_static, CLASS_ERROR, diag::MAP_ERROR, "static declaration of %0 follows non-static declaration", 0, true)
DIAG(err_static_not_bitfield, CLASS_ERROR, diag::MAP_ERROR, "static member %0 cannot be a bit-field", 0, true)
DIAG(err_static_out_of_line, CLASS_ERROR, diag::MAP_ERROR, "'static' can only be specified inside the class definition", 0, true)
DIAG(err_statically_allocated_object, CLASS_ERROR, diag::MAP_ERROR, "interface type cannot be statically allocated", 0, true)
DIAG(err_stmtexpr_file_scope, CLASS_ERROR, diag::MAP_ERROR, "statement expression not allowed at file scope", 0, true)
DIAG(err_storageclass_invalid_for_member, CLASS_ERROR, diag::MAP_ERROR, "storage class specified for a member declaration", 0, true)
DIAG(err_subscript_function_type, CLASS_ERROR, diag::MAP_ERROR, "subscript of pointer to function type %0", 0, true)
DIAG(err_subscript_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "subscript of pointer to incomplete type %0", 0, true)
DIAG(err_subscript_nonfragile_interface, CLASS_ERROR, diag::MAP_ERROR, "subscript requires size of interface %0, which is not constant in non-fragile ABI", 0, true)
DIAG(err_switch_into_protected_scope, CLASS_ERROR, diag::MAP_ERROR, "illegal switch case into protected scope", 0, true)
DIAG(err_tag_definition_of_typedef, CLASS_ERROR, diag::MAP_ERROR, "definition of type %0 conflicts with typedef of the same name", 0, true)
DIAG(err_template_arg_extra_parens, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument cannot be surrounded by parentheses", 0, true)
DIAG(err_template_arg_field, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument refers to non-static data member %0", 0, true)
DIAG(err_template_arg_function_not_extern, CLASS_ERROR, diag::MAP_ERROR, "non-template argument refers to function %0 with internal linkage", 0, true)
DIAG(err_template_arg_list_different_arity, CLASS_ERROR, diag::MAP_ERROR, "%select{too few|too many}0 template arguments for %select{class template|function template|template template parameter|template}1 %2", 0, true)
DIAG(err_template_arg_local_type, CLASS_ERROR, diag::MAP_ERROR, "template argument uses local type %0", 0, true)
DIAG(err_template_arg_method, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument refers to non-static member function %0", 0, true)
DIAG(err_template_arg_must_be_expr, CLASS_ERROR, diag::MAP_ERROR, "template argument for non-type template parameter must be an expression", 0, true)
DIAG(err_template_arg_must_be_template, CLASS_ERROR, diag::MAP_ERROR, "template argument for template template parameter must be a class template", 0, true)
DIAG(err_template_arg_must_be_type, CLASS_ERROR, diag::MAP_ERROR, "template argument for template type parameter must be a type", 0, true)
DIAG(err_template_arg_negative, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument provides negative value '%0' for unsigned template parameter of type %1", 0, true)
DIAG(err_template_arg_no_ref_bind, CLASS_ERROR, diag::MAP_ERROR, "non-type template parameter of reference type %0 cannot bind to template argument of type %1", 0, true)
DIAG(err_template_arg_nontype_ambig, CLASS_ERROR, diag::MAP_ERROR, "template argument for non-type template parameter is treated as type %0", 0, true)
DIAG(err_template_arg_not_class_template, CLASS_ERROR, diag::MAP_ERROR, "template argument does not refer to a class template or template template parameter", 0, true)
DIAG(err_template_arg_not_convertible, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument of type %0 cannot be converted to a value of type %1", 0, true)
DIAG(err_template_arg_not_ice, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument of type %0 is not an integral constant expression", 0, true)
DIAG(err_template_arg_not_integral_or_enumeral, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument of type %0 must have an integral or enumeration type", 0, true)
DIAG(err_template_arg_not_object_or_func, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument does not refer to an object or function", 0, true)
DIAG(err_template_arg_not_object_or_func_form, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument does not directly refer to an object or function", 0, true)
DIAG(err_template_arg_not_pointer_to_member_form, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument is not a pointer to member constant", 0, true)
DIAG(err_template_arg_object_not_extern, CLASS_ERROR, diag::MAP_ERROR, "non-template argument refers to object %0 that does not have external linkage", 0, true)
DIAG(err_template_arg_ref_bind_ignores_quals, CLASS_ERROR, diag::MAP_ERROR, "reference binding of non-type template parameter of type %0 to template argument of type %1 ignores qualifiers", 0, true)
DIAG(err_template_arg_template_params_mismatch, CLASS_ERROR, diag::MAP_ERROR, "template template argument has different template parameters than its corresponding template template parameter", 0, true)
DIAG(err_template_arg_too_large, CLASS_ERROR, diag::MAP_ERROR, "non-type template argument value '%0' is too large for template parameter of type %1", 0, true)
DIAG(err_template_arg_unnamed_type, CLASS_ERROR, diag::MAP_ERROR, "template argument uses unnamed type", 0, true)
DIAG(err_template_instantiate_undefined, CLASS_ERROR, diag::MAP_ERROR, "%select{implicit|explicit}0 instantiation of undefined template %1", 0, true)
DIAG(err_template_kw_refers_to_function_template, CLASS_ERROR, diag::MAP_ERROR, "%0 following the 'template' keyword refers to a function template", 0, true)
DIAG(err_template_kw_refers_to_non_template, CLASS_ERROR, diag::MAP_ERROR, "%0 following the 'template' keyword does not refer to a template", 0, true)
DIAG(err_template_linkage, CLASS_ERROR, diag::MAP_ERROR, "templates must have C++ linkage", 0, true)
DIAG(err_template_nontype_parm_bad_type, CLASS_ERROR, diag::MAP_ERROR, "a non-type template parameter cannot have type %0", 0, true)
DIAG(err_template_nontype_parm_different_type, CLASS_ERROR, diag::MAP_ERROR, "template non-type parameter has a different type %0 in template %select{|template parameter }1redeclaration", 0, true)
DIAG(err_template_outside_namespace_or_class_scope, CLASS_ERROR, diag::MAP_ERROR, "templates can only be declared in namespace or class scope", 0, true)
DIAG(err_template_param_default_arg_missing, CLASS_ERROR, diag::MAP_ERROR, "template parameter missing a default argument", 0, true)
DIAG(err_template_param_default_arg_redefinition, CLASS_ERROR, diag::MAP_ERROR, "template parameter redefines default argument", 0, true)
DIAG(err_template_param_different_kind, CLASS_ERROR, diag::MAP_ERROR, "template parameter has a different kind in template %select{|template parameter }0redeclaration", 0, true)
DIAG(err_template_param_list_different_arity, CLASS_ERROR, diag::MAP_ERROR, "%select{too few|too many}0 template parameters in template %select{|template parameter }1redeclaration", 0, true)
DIAG(err_template_param_list_matches_nontemplate, CLASS_ERROR, diag::MAP_ERROR, "template parameter list matching the non-templated nested type %0 should be empty ('template<>')", 0, true)
DIAG(err_template_param_pack_default_arg, CLASS_ERROR, diag::MAP_ERROR, "template parameter pack cannot have a default argument", 0, true)
DIAG(err_template_param_pack_must_be_last_template_parameter, CLASS_ERROR, diag::MAP_ERROR, "template parameter pack must be the last template parameter", 0, true)
DIAG(err_template_param_shadow, CLASS_ERROR, diag::MAP_ERROR, "declaration of %0 shadows template parameter", 0, true)
DIAG(err_template_qualified_declarator_no_match, CLASS_ERROR, diag::MAP_ERROR, "nested name specifier '%0' for declaration does not refer to a class template or class template partial specialization", 0, true)
DIAG(err_template_recursion_depth_exceeded, CLASS_ERROR, diag::MAP_FATAL, "recursive template instantiation exceeded maximum depth of %0", 0, false)
DIAG(err_template_spec_decl_function_scope, CLASS_ERROR, diag::MAP_ERROR, "%select{class template specialization|class template partial specialization|explicit instantiation}0 of %1 in function scope", 0, true)
DIAG(err_template_spec_decl_out_of_scope, CLASS_ERROR, diag::MAP_ERROR, "class template %select{|partial }0specialization of %1 not in namespace %2", 0, true)
DIAG(err_template_spec_decl_out_of_scope_global, CLASS_ERROR, diag::MAP_ERROR, "class template %select{|partial }0specialization of %1 must occur in the global scope", 0, true)
DIAG(err_template_spec_extra_headers, CLASS_ERROR, diag::MAP_ERROR, "extraneous template parameter list in template specialization or out-of-line template definition", 0, true)
DIAG(err_template_spec_needs_header, CLASS_ERROR, diag::MAP_ERROR, "template specialization requires 'template<>'", 0, true)
DIAG(err_template_spec_needs_template_parameters, CLASS_ERROR, diag::MAP_ERROR, "template specialization or definition requires a template parameter listcorresponding to the nested type %0", 0, true)
DIAG(err_template_spec_redecl_global_scope, CLASS_ERROR, diag::MAP_ERROR, "%select{class template specialization|class template partial specialization|explicit instantiation}0 of %1 must occur at global scope", 0, true)
DIAG(err_template_spec_redecl_out_of_scope, CLASS_ERROR, diag::MAP_ERROR, "%select{class template specialization|class template partial specialization|explicit instantiation}0 of %1 not in a namespace enclosing %2", 0, true)
DIAG(err_template_typedef, CLASS_ERROR, diag::MAP_ERROR, "a typedef cannot be a template", 0, true)
DIAG(err_template_unnamed_class, CLASS_ERROR, diag::MAP_ERROR, "cannot declare a class template with no name", 0, true)
DIAG(err_template_variable, CLASS_ERROR, diag::MAP_ERROR, "variable %0 declared as a template", 0, true)
DIAG(err_template_variable_noparams, CLASS_ERROR, diag::MAP_ERROR, "extraneous 'template<>' in declaration of variable %0", 0, true)
DIAG(err_tentative_def_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "tentative definition has type %0 that is never completed", 0, true)
DIAG(err_tentative_def_incomplete_type_arr, CLASS_ERROR, diag::MAP_ERROR, "tentative definition has array of type %0 that is never completed", 0, true)
DIAG(err_thread_non_global, CLASS_ERROR, diag::MAP_ERROR, "'__thread' variables must have global storage", 0, true)
DIAG(err_thread_non_thread, CLASS_ERROR, diag::MAP_ERROR, "thread-local declaration of %0 follows non-thread-local declaration", 0, true)
DIAG(err_thread_unsupported, CLASS_ERROR, diag::MAP_ERROR, "thread-local storage is unsupported for the current target", 0, true)
DIAG(err_throw_incomplete, CLASS_ERROR, diag::MAP_ERROR, "cannot throw object of incomplete type %0", 0, true)
DIAG(err_throw_incomplete_ptr, CLASS_ERROR, diag::MAP_ERROR, "cannot throw pointer to object of incomplete type %0", 0, true)
DIAG(err_toomany_element_decls, CLASS_ERROR, diag::MAP_ERROR, "only one element declaration is allowed", 0, true)
DIAG(err_type_defined_in_condition, CLASS_ERROR, diag::MAP_ERROR, "types may not be defined in conditions", 0, true)
DIAG(err_type_defined_in_param_type, CLASS_ERROR, diag::MAP_ERROR, "%0 can not be defined in a parameter type", 0, true)
DIAG(err_type_defined_in_result_type, CLASS_ERROR, diag::MAP_ERROR, "%0 can not be defined in the result type of a function", 0, true)
DIAG(err_type_defined_in_type_specifier, CLASS_ERROR, diag::MAP_ERROR, "%0 can not be defined in a type specifier", 0, true)
DIAG(err_typecheck_address_of, CLASS_ERROR, diag::MAP_ERROR, "address of %0 requested", 0, true)
DIAG(err_typecheck_arithmetic_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "arithmetic on pointer to incomplete type %0", 0, true)
DIAG(err_typecheck_array_not_modifiable_lvalue, CLASS_ERROR, diag::MAP_ERROR, "array type %0 is not assignable", 0, true)
DIAG(err_typecheck_assign_const, CLASS_ERROR, diag::MAP_ERROR, "read-only variable is not assignable", 0, true)
DIAG(err_typecheck_bool_condition, CLASS_ERROR, diag::MAP_ERROR, "value of type %0 is not contextually convertible to 'bool'", 0, true)
DIAG(err_typecheck_call_invalid_ordered_compare, CLASS_ERROR, diag::MAP_ERROR, "ordered compare requires two args of floating point type (%0 and %1)", 0, true)
DIAG(err_typecheck_call_not_function, CLASS_ERROR, diag::MAP_ERROR, "called object type %0 is not a function or function pointer", 0, true)
DIAG(err_typecheck_call_too_few_args, CLASS_ERROR, diag::MAP_ERROR, "too few arguments to %select{function|block|method}0 call", 0, true)
DIAG(err_typecheck_call_too_many_args, CLASS_ERROR, diag::MAP_ERROR, "too many arguments to %select{function|block|method}0 call", 0, true)
DIAG(err_typecheck_cast_to_union_no_type, CLASS_ERROR, diag::MAP_ERROR, "cast to union type from type %0 not present in union", 0, true)
DIAG(err_typecheck_choose_expr_requires_constant, CLASS_ERROR, diag::MAP_ERROR, "'__builtin_choose_expr' requires a constant expression", 0, true)
DIAG(err_typecheck_closure_too_many_args, CLASS_ERROR, diag::MAP_ERROR, "too many arguments to closure call", 0, true)
DIAG(err_typecheck_comparison_of_distinct_blocks, CLASS_ERROR, diag::MAP_ERROR, "comparison of distinct block types (%0 and %1)", 0, true)
DIAG(err_typecheck_comparison_of_distinct_pointers, CLASS_ERROR, diag::MAP_ERROR, "comparison of distinct pointer types (%0 and %1)", 0, true)
DIAG(err_typecheck_cond_expect_scalar, CLASS_ERROR, diag::MAP_ERROR, "used type %0 where arithmetic or pointer type is required", 0, true)
DIAG(err_typecheck_cond_incompatible_operands, CLASS_ERROR, diag::MAP_ERROR, "incompatible operand types (%0 and %1)", 0, true)
DIAG(err_typecheck_convert_incompatible, CLASS_ERROR, diag::MAP_ERROR, "incompatible type %2 %1, expected %0", 0, true)
DIAG(err_typecheck_convert_incompatible_block_pointer, CLASS_ERROR, diag::MAP_ERROR, "incompatible block pointer types %2 %1, expected %0", 0, true)
DIAG(err_typecheck_decl_incomplete_type, CLASS_ERROR, diag::MAP_ERROR, "variable has incomplete type %0", 0, true)
DIAG(err_typecheck_duplicate_vector_components_not_mlvalue, CLASS_ERROR, diag::MAP_ERROR, "vector is not assignable (contains duplicate components)", 0, true)
DIAG(err_typecheck_expect_scalar_operand, CLASS_ERROR, diag::MAP_ERROR, "operand of type %0 where arithmetic or pointer type is required", 0, true)
DIAG(err_typecheck_expression_not_modifiable_lvalue, CLASS_ERROR, diag::MAP_ERROR, "expression is not assignable", 0, true)
DIAG(err_typecheck_ext_vector_not_typedef, CLASS_ERROR, diag::MAP_ERROR, "ext_vector_type only applies to types, not variables", 0, true)
DIAG(err_typecheck_field_variable_size, CLASS_ERROR, diag::MAP_ERROR, "fields must have a constant size: 'variable length array in structure' extension will never be supported", 0, true)
DIAG(err_typecheck_illegal_increment_decrement, CLASS_ERROR, diag::MAP_ERROR, "cannot modify value of type %0", 0, true)
DIAG(err_typecheck_incomplete_tag, CLASS_ERROR, diag::MAP_ERROR, "incomplete definition of type %0", 0, true)
DIAG(err_typecheck_incomplete_type_not_modifiable_lvalue, CLASS_ERROR, diag::MAP_ERROR, "incomplete type %0 is not assignable", 0, true)
DIAG(err_typecheck_indirection_requires_pointer, CLASS_ERROR, diag::MAP_ERROR, "indirection requires pointer operand (%0 invalid)", 0, true)
DIAG(err_typecheck_invalid_lvalue_addrof, CLASS_ERROR, diag::MAP_ERROR, "address expression must be an lvalue or a function designator", 0, true)
DIAG(err_typecheck_invalid_operands, CLASS_ERROR, diag::MAP_ERROR, "invalid operands to binary expression (%0 and %1)", 0, true)
DIAG(err_typecheck_invalid_restrict_invalid_pointee, CLASS_ERROR, diag::MAP_ERROR, "pointer to function type %0 may not be 'restrict' qualified", 0, true)
DIAG(err_typecheck_invalid_restrict_not_pointer, CLASS_ERROR, diag::MAP_ERROR, "restrict requires a pointer or reference (%0 is invalid)", 0, true)
DIAG(err_typecheck_ivar_variable_size, CLASS_ERROR, diag::MAP_ERROR, "instance variables must have a constant size", 0, true)
DIAG(err_typecheck_lvalue_casts_not_supported, CLASS_ERROR, diag::MAP_ERROR, "assignment to cast is illegal, lvalue casts are not supported", 0, true)
DIAG(err_typecheck_member_reference_arrow, CLASS_ERROR, diag::MAP_ERROR, "member reference type %0 is not a pointer", 0, true)
DIAG(err_typecheck_member_reference_ivar, CLASS_ERROR, diag::MAP_ERROR, "%0 does not have a member named %1", 0, true)
DIAG(err_typecheck_member_reference_struct_union, CLASS_ERROR, diag::MAP_ERROR, "member reference base type %0 is not a structure or union", 0, true)
DIAG(err_typecheck_member_reference_type, CLASS_ERROR, diag::MAP_ERROR, "cannot refer to type member %0 with '%select{.|->}1'", 0, true)
DIAG(err_typecheck_member_reference_unknown, CLASS_ERROR, diag::MAP_ERROR, "cannot refer to member %0 with '%select{.|->}1'", 0, true)
DIAG(err_typecheck_negative_array_size, CLASS_ERROR, diag::MAP_ERROR, "array size is negative", 0, true)
DIAG(err_typecheck_no_member, CLASS_ERROR, diag::MAP_ERROR, "no member named %0", 0, true)
DIAG(err_typecheck_non_object_not_modifiable_lvalue, CLASS_ERROR, diag::MAP_ERROR, "non-object type %0 is not assignable", 0, true)
DIAG(err_typecheck_pointer_arith_function_type, CLASS_ERROR, diag::MAP_ERROR, "arithmetic on pointer to function type %0", 0, true)
DIAG(err_typecheck_pointer_arith_void_type, CLASS_ERROR, diag::MAP_ERROR, "arithmetic on pointer to void type", 0, true)
DIAG(err_typecheck_sclass_fscope, CLASS_ERROR, diag::MAP_ERROR, "illegal storage class on file-scoped variable", 0, true)
DIAG(err_typecheck_sclass_func, CLASS_ERROR, diag::MAP_ERROR, "illegal storage class on function", 0, true)
DIAG(err_typecheck_statement_requires_integer, CLASS_ERROR, diag::MAP_ERROR, "statement requires expression of integer type (%0 invalid)", 0, true)
DIAG(err_typecheck_statement_requires_scalar, CLASS_ERROR, diag::MAP_ERROR, "statement requires expression of scalar type (%0 invalid)", 0, true)
DIAG(err_typecheck_sub_ptr_compatible, CLASS_ERROR, diag::MAP_ERROR, "%0 and %1 are not pointers to compatible types", 0, true)
DIAG(err_typecheck_sub_ptr_object, CLASS_ERROR, diag::MAP_ERROR, "subtraction of pointer %0 requires pointee to be a complete object type", 0, true)
DIAG(err_typecheck_subscript_not_integer, CLASS_ERROR, diag::MAP_ERROR, "array subscript is not an integer", 0, true)
DIAG(err_typecheck_subscript_value, CLASS_ERROR, diag::MAP_ERROR, "subscripted value is not an array, pointer, or vector", 0, true)
DIAG(err_typecheck_unary_expr, CLASS_ERROR, diag::MAP_ERROR, "invalid argument type %0 to unary expression", 0, true)
DIAG(err_typecheck_vector_comparison, CLASS_ERROR, diag::MAP_ERROR, "comparison of vector types (%0 and %1) not supported yet", 0, true)
DIAG(err_typecheck_vector_not_convertable, CLASS_ERROR, diag::MAP_ERROR, "can't convert between vector values of different size (%0 and %1)", 0, true)
DIAG(err_typedef_not_bitfield, CLASS_ERROR, diag::MAP_ERROR, "typedef member %0 cannot be a bit-field", 0, true)
DIAG(err_typename_nested_not_found, CLASS_ERROR, diag::MAP_ERROR, "no type named %0 in %1", 0, true)
DIAG(err_typename_nested_not_found_global, CLASS_ERROR, diag::MAP_ERROR, "no type named %0 in the global namespace", 0, true)
DIAG(err_typename_nested_not_type, CLASS_ERROR, diag::MAP_ERROR, "typename specifier refers to non-type member %0", 0, true)
DIAG(err_types_compatible_p_in_cplusplus, CLASS_ERROR, diag::MAP_ERROR, "__builtin_types_compatible_p is not valid in C++", 0, true)
DIAG(err_undeclared_label_use, CLASS_ERROR, diag::MAP_ERROR, "use of undeclared label '%0'", 0, true)
DIAG(err_undeclared_protocol, CLASS_ERROR, diag::MAP_ERROR, "cannot find protocol declaration for %0", 0, true)
DIAG(err_undeclared_use, CLASS_ERROR, diag::MAP_ERROR, "use of undeclared '%0'", 0, true)
DIAG(err_undeclared_var_use, CLASS_ERROR, diag::MAP_ERROR, "use of undeclared identifier %0", 0, true)
DIAG(err_undef_interface, CLASS_ERROR, diag::MAP_ERROR, "cannot find interface declaration for %0", 0, true)
DIAG(err_undef_superclass, CLASS_ERROR, diag::MAP_ERROR, "cannot find interface declaration for %0, superclass of %1", 0, true)
DIAG(err_unelaborated_friend_type, CLASS_ERROR, diag::MAP_ERROR, "must specify '%select{class|union}0' in a friend %select{class|union}0 declaration", 0, true)
DIAG(err_unexpected_friend, CLASS_ERROR, diag::MAP_ERROR, "friends can only be classes or functions", 0, true)
DIAG(err_unexpected_interface, CLASS_ERROR, diag::MAP_ERROR, "unexpected interface name %0: expected expression", 0, true)
DIAG(err_unexpected_namespace, CLASS_ERROR, diag::MAP_ERROR, "unexpected namespace name %0: expected expression", 0, true)
DIAG(err_unexpected_typedef, CLASS_ERROR, diag::MAP_ERROR, "unexpected type name %0: expected expression", 0, true)
DIAG(err_uninitialized_member_for_assign, CLASS_ERROR, diag::MAP_ERROR, "cannot define the implicit default assignment operator for %0, because non-static %select{reference|const}1 member %2 can't use default assignment operator", 0, true)
DIAG(err_unintialized_member, CLASS_ERROR, diag::MAP_ERROR, "cannot define the implicit default constructor for %0, because %select{reference|const}1 member %2 cannot be default-initialized", 0, true)
DIAG(err_union_as_base_class, CLASS_ERROR, diag::MAP_ERROR, "unions cannot be base classes", 0, true)
DIAG(err_unknown_machine_mode, CLASS_ERROR, diag::MAP_ERROR, "unknown machine mode %0", 0, true)
DIAG(err_unsupported_global_register, CLASS_ERROR, diag::MAP_ERROR, "global register variables are not supported", 0, true)
DIAG(err_unsupported_machine_mode, CLASS_ERROR, diag::MAP_ERROR, "unsupported machine mode %0", 0, true)
DIAG(err_unsupported_pragma_weak, CLASS_ERROR, diag::MAP_ERROR, "using '#pragma weak' to refer to an undeclared identifier is not yet supported", 0, true)
DIAG(err_unsupported_vector_size, CLASS_ERROR, diag::MAP_ERROR, "unsupported type %0 for vector_size attribute, please use on typedef", 0, true)
DIAG(err_unusual_main_decl, CLASS_ERROR, diag::MAP_ERROR, "'main' is not allowed to be declared %select{static|inline|static or inline}0", 0, true)
DIAG(err_use_continuation_class, CLASS_ERROR, diag::MAP_ERROR, "attribute of property in continuation class of %0 can only  be 'readwrite'", 0, true)
DIAG(err_use_of_default_argument_to_function_declared_later, CLASS_ERROR, diag::MAP_ERROR, "use of default argument to function %0 that is declared later in class %1", 0, true)
DIAG(err_use_with_wrong_tag, CLASS_ERROR, diag::MAP_ERROR, "use of %0 with tag type that does not match previous declaration", 0, true)
DIAG(err_using_requires_qualname, CLASS_ERROR, diag::MAP_ERROR, "using declaration requires a qualified name", 0, true)
DIAG(err_using_typename_non_type, CLASS_ERROR, diag::MAP_ERROR, "'typename' keyword used on a non-type", 0, true)
DIAG(err_va_start_used_in_non_variadic_function, CLASS_ERROR, diag::MAP_ERROR, "'va_start' used in function with fixed args", 0, true)
DIAG(err_value_init_for_array_type, CLASS_ERROR, diag::MAP_ERROR, "array types cannot be value-initialized", 0, true)
DIAG(err_variable_object_no_init, CLASS_ERROR, diag::MAP_ERROR, "variable-sized object may not be initialized", 0, true)
DIAG(err_vector_incorrect_num_initializers, CLASS_ERROR, diag::MAP_ERROR, "%select{too many|too few}0 elements in vector initialization (expected %1 elements, have %2)", 0, true)
DIAG(err_virtual_non_function, CLASS_ERROR, diag::MAP_ERROR, "'virtual' can only appear on non-static member functions", 0, true)
DIAG(err_virtual_out_of_class, CLASS_ERROR, diag::MAP_ERROR, "'virtual' can only be specified inside the class definition", 0, true)
DIAG(err_vla_decl_has_extern_linkage, CLASS_ERROR, diag::MAP_ERROR, "variable length array declaration can not have 'extern' linkage", 0, true)
DIAG(err_vla_decl_has_static_storage, CLASS_ERROR, diag::MAP_ERROR, "variable length array declaration can not have 'static' storage duration", 0, true)
DIAG(err_vla_decl_in_file_scope, CLASS_ERROR, diag::MAP_ERROR, "variable length array declaration not allowed at file scope", 0, true)
DIAG(err_vm_decl_has_extern_linkage, CLASS_ERROR, diag::MAP_ERROR, "variably modified type declaration can not have 'extern' linkage", 0, true)
DIAG(err_vm_decl_in_file_scope, CLASS_ERROR, diag::MAP_ERROR, "variably modified type declaration not allowed at file scope", 0, true)
DIAG(err_vm_func_decl, CLASS_ERROR, diag::MAP_ERROR, "function declaration cannot have variably modified type", 0, true)
DIAG(err_void_only_param, CLASS_ERROR, diag::MAP_ERROR, "'void' must be the first and only parameter if specified", 0, true)
DIAG(err_void_param_qualified, CLASS_ERROR, diag::MAP_ERROR, "'void' as parameter must not have type qualifiers", 0, true)
DIAG(error_bad_category_property_decl, CLASS_ERROR, diag::MAP_ERROR, "property implementation must have its declaration in the category %0", 0, true)
DIAG(error_bad_property_context, CLASS_ERROR, diag::MAP_ERROR, "property implementation must be in a class or category implementation", 0, true)
DIAG(error_bad_property_decl, CLASS_ERROR, diag::MAP_ERROR, "property implementation must have its declaration in interface %0", 0, true)
DIAG(error_duplicate_ivar_use, CLASS_ERROR, diag::MAP_ERROR, "synthesized properties %0 and %1 both claim ivar %2", 0, true)
DIAG(error_dynamic_property_ivar_decl, CLASS_ERROR, diag::MAP_ERROR, "dynamic property can not have ivar specification", 0, true)
DIAG(error_ivar_in_superclass_use, CLASS_ERROR, diag::MAP_ERROR, "property %0 attempting to use ivar %1 declared in super class %2", 0, true)
DIAG(error_ivar_use_in_class_method, CLASS_ERROR, diag::MAP_ERROR, "instance variable %0 accessed in class method", 0, true)
DIAG(error_missing_method_context, CLASS_ERROR, diag::MAP_ERROR, "missing context for method declaration", 0, true)
DIAG(error_missing_property_context, CLASS_ERROR, diag::MAP_ERROR, "missing context for property implementation declaration", 0, true)
DIAG(error_missing_property_interface, CLASS_ERROR, diag::MAP_ERROR, "property implementation in a category with no category declaration", 0, true)
DIAG(error_missing_property_ivar_decl, CLASS_ERROR, diag::MAP_ERROR, "synthesized property %0 must either be named the same as a compatible ivar or must explicitly name an ivar", 0, true)
DIAG(error_multiple_base_initialization, CLASS_ERROR, diag::MAP_ERROR, "multiple initializations given for base %0", 0, true)
DIAG(error_multiple_mem_initialization, CLASS_ERROR, diag::MAP_ERROR, "multiple initializations given for non-static member '%0'", 0, true)
DIAG(error_no_super_class, CLASS_ERROR, diag::MAP_ERROR, "no super class declared in @interface for %0", 0, true)
DIAG(error_no_super_class_message, CLASS_ERROR, diag::MAP_ERROR, "no @interface declaration found in class messaging of %0", 0, true)
DIAG(error_nosetter_property_assignment, CLASS_ERROR, diag::MAP_ERROR, "setter method is needed to assign to object using property assignment syntax", 0, true)
DIAG(error_objc_synchronized_expects_object, CLASS_ERROR, diag::MAP_ERROR, "@synchronized requires an Objective-C object type (%0 invalid)", 0, true)
DIAG(error_objc_throw_expects_object, CLASS_ERROR, diag::MAP_ERROR, "@throw requires an Objective-C object type (%0 invalid)", 0, true)
DIAG(error_private_ivar_access, CLASS_ERROR, diag::MAP_ERROR, "instance variable %0 is private", 0, false)
DIAG(error_property_implemented, CLASS_ERROR, diag::MAP_ERROR, "property %0 is already implemented", 0, true)
DIAG(error_property_ivar_type, CLASS_ERROR, diag::MAP_ERROR, "type of property %0 does not match type of ivar %1", 0, true)
DIAG(error_protected_ivar_access, CLASS_ERROR, diag::MAP_ERROR, "instance variable %0 is protected", 0, false)
DIAG(error_readonly_property_assignment, CLASS_ERROR, diag::MAP_ERROR, "assigning to property with 'readonly' attribute not allowed", 0, true)
DIAG(error_rethrow_used_outside_catch, CLASS_ERROR, diag::MAP_ERROR, "@throw (rethrow) used outside of a @catch block", 0, true)
DIAG(error_strong_property, CLASS_ERROR, diag::MAP_ERROR, "existing ivar %1 for a __strong property %0 must be garbage collectable", 0, true)
DIAG(error_synthesize_category_decl, CLASS_ERROR, diag::MAP_ERROR, "@synthesize not allowed in a category's implementation", 0, true)
DIAG(error_synthesized_ivar_yet_not_supported, CLASS_ERROR, diag::MAP_ERROR, "instance variable synthesis not yet supported (need to declare %0 explicitly)", 0, true)
DIAG(error_weak_property, CLASS_ERROR, diag::MAP_ERROR, "existing ivar %1 for __weak property %0 must be __weak", 0, true)
DIAG(ext_anon_param_requires_type_specifier, CLASS_EXTENSION, diag::MAP_IGNORE, "type specifier required for unnamed parameter, defaults to int", 0, true)
DIAG(ext_anonymous_struct, CLASS_EXTENSION, diag::MAP_IGNORE, "anonymous structs are a GNU extension", 0, true)
DIAG(ext_anonymous_union, CLASS_EXTENSION, diag::MAP_IGNORE, "anonymous unions are a GNU extension in C", 0, true)
DIAG(ext_c99_array_usage, CLASS_EXTENSION, diag::MAP_IGNORE, "use of C99-specific array features, accepted as an extension", 0, true)
DIAG(ext_cast_fn_obj, CLASS_EXTENSION, diag::MAP_IGNORE, "cast between pointer-to-function and pointer-to-object is an extension", 0, true)
DIAG(ext_enum_value_not_int, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C restricts enumerator values to range of 'int' (%0 is too large)", 0, true)
DIAG(ext_explicit_instantiation_after_specialization, CLASS_EXTENSION, diag::MAP_IGNORE, "explicit instantiation of %0 that occurs after an explicit specialization will be ignored (C++0x extension)", 0, true)
DIAG(ext_expr_not_ice, CLASS_EXTENSION, diag::MAP_IGNORE, "expression is not integer constant expression (but is allowed as an extension)", 0, true)
DIAG(ext_flexible_array_in_array, CLASS_EXTENSION, diag::MAP_IGNORE, "%0 may not be used as an array element due to flexible array member", 0, true)
DIAG(ext_flexible_array_in_struct, CLASS_EXTENSION, diag::MAP_IGNORE, "%0 may not be nested in a struct due to flexible array member", 0, true)
DIAG(ext_flexible_array_init, CLASS_EXTENSION, diag::MAP_IGNORE, "flexible array initialization is a GNU extension", 0, true)
DIAG(ext_forward_ref_enum, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C forbids forward references to 'enum' types", 0, true)
DIAG(ext_freestanding_complex, CLASS_EXTENSION, diag::MAP_IGNORE, "complex numbers are an extension in a freestanding C99 implementation", 0, true)
DIAG(ext_friend_inner_class, CLASS_EXTENSION, diag::MAP_IGNORE, "C++ 98 does not allow inner classes as friends", 0, true)
DIAG(ext_gnu_ptr_func_arith, CLASS_EXTENSION, diag::MAP_IGNORE, "arithmetic on pointer to function type %0 is a GNU extension", 0, true)
DIAG(ext_gnu_void_ptr, CLASS_EXTENSION, diag::MAP_IGNORE, "use of GNU void* extension", 0, true)
DIAG(ext_implicit_function_decl, CLASS_EXTENSION, diag::MAP_IGNORE, "implicit declaration of function %0 is invalid in C99", "implicit-function-declaration", true)
DIAG(ext_implicit_lib_function_decl, CLASS_EXTENSION, diag::MAP_WARNING, "implicitly declaring C library function '%0' with type %1", 0, true)
DIAG(ext_integer_complement_complex, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C does not support '~' for complex conjugation of %0", 0, true)
DIAG(ext_integer_increment_complex, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C does not support '++'/'--' on complex integer type %0", 0, true)
DIAG(ext_invalid_sign_spec, CLASS_EXTENSION, diag::MAP_IGNORE, "'%0' cannot be signed or unsigned", 0, true)
DIAG(ext_missing_declspec, CLASS_EXTENSION, diag::MAP_WARNING, "declaration specifier missing, defaulting to 'int'", 0, true)
DIAG(ext_missing_type_specifier, CLASS_EXTENSION, diag::MAP_WARNING, "type specifier missing, defaults to 'int'", "implicit-int", true)
DIAG(ext_mixed_decls_code, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C90 forbids mixing declarations and code", 0, true)
DIAG(ext_null_pointer_expr_not_ice, CLASS_EXTENSION, diag::MAP_IGNORE, "null pointer expression is not an integer constant expression (but is allowed as an extension)", 0, true)
DIAG(ext_offsetof_extended_field_designator, CLASS_EXTENSION, diag::MAP_IGNORE, "using extended field designator is an extension", 0, true)
DIAG(ext_param_not_declared, CLASS_EXTENSION, diag::MAP_IGNORE, "parameter %0 was not declared, defaulting to type 'int'", 0, true)
DIAG(ext_param_promoted_not_compatible_with_prototype, CLASS_EXTENSION, diag::MAP_WARNING, "promoted type %0 of K&R function parameter is not compatible with the parameter type %1 declared in a previous prototype", 0, true)
DIAG(ext_predef_outside_function, CLASS_WARNING, diag::MAP_WARNING, "predefined identifier is only valid inside function", 0, true)
DIAG(ext_return_has_expr, CLASS_EXTENSION, diag::MAP_WARNING, "void %select{function|method}1 %0 should not return a value", "return-type", true)
DIAG(ext_return_has_void_expr, CLASS_EXTENSION, diag::MAP_IGNORE, "void %select{function|method}1 %0 should not return void expression", 0, true)
DIAG(ext_return_missing_expr, CLASS_EXTENSION, diag::MAP_WARNING, "non-void %select{function|method}1 %0 should return a value", "return-type", true)
DIAG(ext_sizeof_function_type, CLASS_EXTENSION, diag::MAP_IGNORE, "invalid application of 'sizeof' to a function type", 0, true)
DIAG(ext_sizeof_void_type, CLASS_EXTENSION, diag::MAP_IGNORE, "invalid application of '%0' to a void type", 0, true)
DIAG(ext_subscript_non_lvalue, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C90 does not allow subscripting non-lvalue array", 0, true)
DIAG(ext_typecheck_addrof_void, CLASS_EXTENSION, diag::MAP_IGNORE, "ISO C forbids taking the address of an expression of type 'void'", 0, true)
DIAG(ext_typecheck_base_super, CLASS_EXTENSION, diag::MAP_WARNING, "method parameter type %0 does not match super class method parameter type %1", 0, true)
DIAG(ext_typecheck_cast_nonscalar, CLASS_EXTENSION, diag::MAP_IGNORE, "C99 forbids casting nonscalar type %0 to the same type", 0, true)
DIAG(ext_typecheck_cast_to_union, CLASS_EXTENSION, diag::MAP_IGNORE, "C99 forbids casts to union type", 0, true)
DIAG(ext_typecheck_comparison_of_distinct_pointers, CLASS_EXTENSION, diag::MAP_WARNING, "comparison of distinct pointer types (%0 and %1)", 0, true)
DIAG(ext_typecheck_comparison_of_pointer_integer, CLASS_EXTENSION, diag::MAP_WARNING, "comparison between pointer and integer (%0 and %1)", 0, true)
DIAG(ext_typecheck_cond_incompatible_operands, CLASS_EXTENSION, diag::MAP_WARNING, "incompatible operand types (%0 and %1)", 0, true)
DIAG(ext_typecheck_cond_one_void, CLASS_EXTENSION, diag::MAP_IGNORE, "C99 forbids conditional expressions with only one void side", 0, true)
DIAG(ext_typecheck_convert_discards_qualifiers, CLASS_EXTENSION, diag::MAP_WARNING, "%2 %1 discards qualifiers, expected %0", 0, true)
DIAG(ext_typecheck_convert_incompatible_pointer, CLASS_EXTENSION, diag::MAP_WARNING, "incompatible pointer types %2 %1, expected %0", 0, true)
DIAG(ext_typecheck_convert_incompatible_pointer_sign, CLASS_EXTENSION, diag::MAP_WARNING, "pointer types point to integer types with different sign %2 %1, expected %0", "pointer-sign", true)
DIAG(ext_typecheck_convert_int_pointer, CLASS_EXTENSION, diag::MAP_WARNING, "incompatible integer to pointer conversion %2 %1, expected %0", 0, true)
DIAG(ext_typecheck_convert_pointer_int, CLASS_EXTENSION, diag::MAP_WARNING, "incompatible pointer to integer conversion %2 %1, expected %0", 0, true)
DIAG(ext_typecheck_convert_pointer_void_func, CLASS_EXTENSION, diag::MAP_IGNORE, "%2 %1 converts between void* and function pointer, expected %0", 0, true)
DIAG(ext_typecheck_decl_incomplete_type, CLASS_EXTENSION, diag::MAP_WARNING, "tentative definition of variable with internal linkage has incomplete non-array type %0", 0, true)
DIAG(ext_typecheck_expression_not_constant_but_accepted, CLASS_EXTENSION, diag::MAP_IGNORE, "expression is not a constant, but is accepted as one by GNU extensions", 0, true)
DIAG(ext_typecheck_ordered_comparison_of_function_pointers, CLASS_EXTENSION, diag::MAP_WARNING, "ordered comparison of function pointers (%0 and %1)", 0, true)
DIAG(ext_typecheck_ordered_comparison_of_pointer_integer, CLASS_EXTENSION, diag::MAP_WARNING, "ordered comparison between pointer and integer (%0 and %1)", 0, true)
DIAG(ext_typecheck_zero_array_size, CLASS_EXTENSION, diag::MAP_IGNORE, "zero size arrays are an extension", 0, true)
DIAG(ext_typedef_without_a_name, CLASS_EXTENSION, diag::MAP_WARNING, "typedef requires a name", 0, true)
DIAG(ext_variable_sized_type_in_struct, CLASS_EXTENSION, diag::MAP_WARNING, "field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension", 0, true)
DIAG(ext_vla, CLASS_EXTENSION, diag::MAP_IGNORE, "variable length arrays are a C99 feature, accepted as an extension", 0, true)
DIAG(note_ambiguous_candidate, CLASS_NOTE, diag::MAP_FATAL, "candidate found by name lookup is %q0", 0, true)
DIAG(note_ambiguous_member_found, CLASS_NOTE, diag::MAP_FATAL, "member found by ambiguous name lookup", 0, true)
DIAG(note_attribute_overloadable_prev_overload, CLASS_NOTE, diag::MAP_FATAL, "previous overload of function is here", 0, true)
DIAG(note_declared_at, CLASS_NOTE, diag::MAP_FATAL, "declared at", 0, true)
DIAG(note_default_arg_instantiation_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of default argument for '%0' required here", 0, true)
DIAG(note_default_argument_declared_here, CLASS_NOTE, diag::MAP_FATAL, "default argument declared here", 0, true)
DIAG(note_explicit_template_arg_substitution_here, CLASS_NOTE, diag::MAP_FATAL, "while substituting explicitly-specified template arguments into function template %f, here", 0, true)
DIAG(note_field_designator_found, CLASS_NOTE, diag::MAP_FATAL, "field designator refers here", 0, true)
DIAG(note_fieldorbase_initialized_here, CLASS_NOTE, diag::MAP_FATAL, "%select{field|base}0 %1", 0, true)
DIAG(note_first_required_here, CLASS_NOTE, diag::MAP_FATAL, "synthesized method is first required here", 0, true)
DIAG(note_flexible_array_member, CLASS_NOTE, diag::MAP_FATAL, "initialized flexible array member %0 is here", 0, true)
DIAG(note_function_template_deduction_instantiation_here, CLASS_NOTE, diag::MAP_FATAL, "while substituting deduced template arguments into function template %0, here", 0, true)
DIAG(note_function_template_spec_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of function template specialization %q0 requested here", 0, true)
DIAG(note_inheritance_implicitly_private_here, CLASS_NOTE, diag::MAP_FATAL, "inheritance is implicitly 'private'", 0, true)
DIAG(note_inheritance_specifier_here, CLASS_NOTE, diag::MAP_FATAL, "'%0' inheritance specifier here", 0, true)
DIAG(note_local_variable_declared_here, CLASS_NOTE, diag::MAP_FATAL, "%0 declared here", 0, true)
DIAG(note_member_def_close_match, CLASS_NOTE, diag::MAP_FATAL, "member declaration nearly matches", 0, true)
DIAG(note_member_of_template_here, CLASS_NOTE, diag::MAP_FATAL, "member is declared here", 0, true)
DIAG(note_member_reference_needs_call, CLASS_NOTE, diag::MAP_FATAL, "perhaps you meant to call this function with '()'?", 0, true)
DIAG(note_method_sent_forward_class, CLASS_NOTE, diag::MAP_FATAL, "method %0 is used for the forward class", 0, true)
DIAG(note_nontemplate_decl_here, CLASS_NOTE, diag::MAP_FATAL, "non-templated declaration is here", 0, true)
DIAG(note_nontrivial_has_nontrivial, CLASS_NOTE, diag::MAP_FATAL, "because type %0 has a %select{member|base class}1 with a non-trivial %select{constructor|copy constructor|copy assignment operator|destructor}2", 0, true)
DIAG(note_nontrivial_has_virtual, CLASS_NOTE, diag::MAP_FATAL, "because type %0 has a virtual %select{member function|base class}1", 0, true)
DIAG(note_nontrivial_user_defined, CLASS_NOTE, diag::MAP_FATAL, "because type %0 has a user-declared %select{constructor|copy constructor|copy assignment operator|destructor}1", 0, true)
DIAG(note_overridden_virtual_function, CLASS_NOTE, diag::MAP_FATAL, "overridden virtual function is here", 0, true)
DIAG(note_partial_spec_deduct_instantiation_here, CLASS_NOTE, diag::MAP_FATAL, "during template argument deduction for class template partial specialization %0, here", 0, true)
DIAG(note_partial_spec_unused_parameter, CLASS_NOTE, diag::MAP_FATAL, "non-deducible template parameter %0", 0, true)
DIAG(note_please_include_header, CLASS_NOTE, diag::MAP_FATAL, "please include the header <%0> or explicitly provide a declaration for '%1'", 0, true)
DIAG(note_previous_access_declaration, CLASS_NOTE, diag::MAP_FATAL, "previously declared '%1' here", 0, true)
DIAG(note_previous_builtin_declaration, CLASS_NOTE, diag::MAP_FATAL, "%0 is a builtin with type %1", 0, true)
DIAG(note_previous_class_decl, CLASS_NOTE, diag::MAP_FATAL, "%0 declared here", 0, true)
DIAG(note_previous_exception_handler, CLASS_NOTE, diag::MAP_FATAL, "for type %0", 0, true)
DIAG(note_previous_explicit_instantiation, CLASS_NOTE, diag::MAP_FATAL, "previous explicit instantiation is here", 0, true)
DIAG(note_previous_initializer, CLASS_NOTE, diag::MAP_FATAL, "previous initialization %select{|with side effects }0is here%select{| (side effects may not occur at run time)}0", 0, true)
DIAG(note_previous_template_specialization, CLASS_NOTE, diag::MAP_FATAL, "previous template specialization is here", 0, true)
DIAG(note_property_impl_required, CLASS_NOTE, diag::MAP_FATAL, "implementation is here", 0, true)
DIAG(note_protected_by___block, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses setup of __block variable", 0, true)
DIAG(note_protected_by_cleanup, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of declaration with __attribute__((cleanup))", 0, true)
DIAG(note_protected_by_cxx_catch, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of catch block", 0, true)
DIAG(note_protected_by_cxx_try, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of try block", 0, true)
DIAG(note_protected_by_objc_catch, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of @catch block", 0, true)
DIAG(note_protected_by_objc_finally, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of @finally block", 0, true)
DIAG(note_protected_by_objc_synchronized, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of @synchronized block", 0, true)
DIAG(note_protected_by_objc_try, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of @try block", 0, true)
DIAG(note_protected_by_vla, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of variable length array", 0, true)
DIAG(note_protected_by_vla_typedef, CLASS_NOTE, diag::MAP_FATAL, "jump bypasses initialization of VLA typedef", 0, true)
DIAG(note_pure_virtual_function, CLASS_NOTE, diag::MAP_FATAL, "pure virtual function %0", 0, true)
DIAG(note_sentinel_here, CLASS_NOTE, diag::MAP_FATAL, "%select{function|method|block}0 has been explicitly marked sentinel here", 0, true)
DIAG(note_template_arg_internal_object, CLASS_NOTE, diag::MAP_FATAL, "non-template argument refers to %select{function|object}0 here", 0, true)
DIAG(note_template_arg_refers_here, CLASS_NOTE, diag::MAP_FATAL, "non-template argument refers here", 0, true)
DIAG(note_template_arg_refers_here_func, CLASS_NOTE, diag::MAP_FATAL, "template argument refers to function template %0, here", 0, true)
DIAG(note_template_class_instantiation_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of template class %0 requested here", 0, true)
DIAG(note_template_decl_here, CLASS_NOTE, diag::MAP_FATAL, "template is declared here", 0, true)
DIAG(note_template_export_unsupported, CLASS_NOTE, diag::MAP_FATAL, "exported templates are unsupported", 0, true)
DIAG(note_template_member_class_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of member class %0 requested here", 0, true)
DIAG(note_template_member_function_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of member function %q0 requested here", 0, true)
DIAG(note_template_nontype_parm_different_type, CLASS_NOTE, diag::MAP_FATAL, "template non-type parameter has a different type %0 in template argument", 0, true)
DIAG(note_template_nontype_parm_prev_declaration, CLASS_NOTE, diag::MAP_FATAL, "previous non-type template parameter with type %0 is here", 0, true)
DIAG(note_template_param_different_kind, CLASS_NOTE, diag::MAP_FATAL, "template parameter has a different kind in template argument", 0, true)
DIAG(note_template_param_here, CLASS_NOTE, diag::MAP_FATAL, "template parameter is declared here", 0, true)
DIAG(note_template_param_list_different_arity, CLASS_NOTE, diag::MAP_FATAL, "%select{too few|too many}0 template parameters in template template argument", 0, true)
DIAG(note_template_param_prev_default_arg, CLASS_NOTE, diag::MAP_FATAL, "previous default template argument defined here", 0, true)
DIAG(note_template_prev_declaration, CLASS_NOTE, diag::MAP_FATAL, "previous template %select{declaration|template parameter}0 is here", 0, true)
DIAG(note_template_recursion_depth, CLASS_NOTE, diag::MAP_FATAL, "use -ftemplate-depth-N to increase recursive template instantiation depth", 0, true)
DIAG(note_template_static_data_member_def_here, CLASS_NOTE, diag::MAP_FATAL, "in instantiation of static data member %q0 requested here", 0, true)
DIAG(note_template_unnamed_type_here, CLASS_NOTE, diag::MAP_FATAL, "unnamed type used in template argument was declared here", 0, true)
DIAG(note_transparent_union_first_field_size_align, CLASS_NOTE, diag::MAP_FATAL, "%select{alignment|size}0 of first field is %1 bits", 0, true)
DIAG(note_typename_refers_here, CLASS_NOTE, diag::MAP_FATAL, "referenced member %0 is declared here", 0, true)
DIAG(note_unavailable_here, CLASS_NOTE, diag::MAP_FATAL, "function has been explicitly marked %select{unavailable|deleted}0 here", 0, true)
DIAG(note_uninit_reference_member, CLASS_NOTE, diag::MAP_FATAL, "uninitialized reference member is here", 0, true)
DIAG(unsup_function_template_partial_ordering, CLASS_WARNING, diag::MAP_WARNING, "partial ordering of function templates is unsupported; overload resolution may result in an ambiguity that would not occur with a conforming compiler", 0, true)
DIAG(unsup_template_partial_spec_ordering, CLASS_ERROR, diag::MAP_ERROR, "partial ordering of class template partial specializations is not yet supported", 0, true)
DIAG(warn_accessor_property_type_mismatch, CLASS_WARNING, diag::MAP_WARNING, "type of property %0 does not match type of accessor %1", 0, true)
DIAG(warn_attribute_ignored, CLASS_WARNING, diag::MAP_WARNING, "%0 attribute ignored", 0, true)
DIAG(warn_attribute_ignored_for_field_of_type, CLASS_WARNING, diag::MAP_WARNING, "%0 attribute ignored for field of type %1", 0, true)
DIAG(warn_attribute_malloc_pointer_only, CLASS_WARNING, diag::MAP_WARNING, "'malloc' attribute only applies to functions returning a pointer type", 0, true)
DIAG(warn_attribute_method_def, CLASS_WARNING, diag::MAP_WARNING, "method attribute can only be specified on method declarations", 0, true)
DIAG(warn_attribute_nonnull_no_pointers, CLASS_WARNING, diag::MAP_WARNING, "'nonnull' attribute applied to function with no pointer arguments", 0, true)
DIAG(warn_attribute_precede_definition, CLASS_WARNING, diag::MAP_WARNING, "attribute declaration must precede definition", 0, true)
DIAG(warn_attribute_sentinel_named_arguments, CLASS_WARNING, diag::MAP_WARNING, "'sentinel' attribute requires named arguments", 0, true)
DIAG(warn_attribute_sentinel_not_variadic, CLASS_WARNING, diag::MAP_WARNING, "'sentinel' attribute only supported for variadic %select{functions|blocks}0", 0, true)
DIAG(warn_attribute_type_not_supported, CLASS_WARNING, diag::MAP_WARNING, "'%0' attribute argument not supported: %1", 0, true)
DIAG(warn_attribute_unknown_visibility, CLASS_WARNING, diag::MAP_WARNING, "unknown visibility '%1'", 0, true)
DIAG(warn_attribute_weak_import_invalid_on_definition, CLASS_WARNING, diag::MAP_WARNING, "'weak_import' attribute cannot be specified on a definition", 0, true)
DIAG(warn_attribute_weak_on_field, CLASS_WARNING, diag::MAP_WARNING, "__weak attribute cannot be specified on a field declaration", 0, true)
DIAG(warn_attribute_weak_on_local, CLASS_WARNING, diag::MAP_WARNING, "__weak attribute cannot be specified on an automatic variable", 0, true)
DIAG(warn_attribute_wrong_decl_type, CLASS_WARNING, diag::MAP_WARNING, "%0 attribute only applies to %select{function|union|variable and function|function or method|parameter|parameter or Objective-C method |function, method or block}1 types", 0, true)
DIAG(warn_bad_receiver_type, CLASS_WARNING, diag::MAP_WARNING, "receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'", 0, true)
DIAG(warn_base_initialized, CLASS_WARNING, diag::MAP_IGNORE, "base class %0 will be initialized after", "reorder", true)
DIAG(warn_braces_around_scalar_init, CLASS_WARNING, diag::MAP_WARNING, "braces around scalar initializer", 0, true)
DIAG(warn_call_wrong_number_of_arguments, CLASS_WARNING, diag::MAP_WARNING, "too %select{few|many}0 arguments in call to %1", 0, true)
DIAG(warn_cannot_pass_non_pod_arg_to_vararg, CLASS_WARNING, diag::MAP_WARNING, "cannot pass object of non-POD type %0 through variadic %select{function|block|method}1; call will abort at runtime", 0, true)
DIAG(warn_case_empty_range, CLASS_WARNING, diag::MAP_WARNING, "empty case range specified", 0, true)
DIAG(warn_case_value_overflow, CLASS_WARNING, diag::MAP_WARNING, "overflow converting case value to switch condition type (%0 to %1)", 0, true)
DIAG(warn_cfstring_literal_contains_nul_character, CLASS_WARNING, diag::MAP_WARNING, "CFString literal contains NUL character", 0, true)
DIAG(warn_class_method_not_found, CLASS_WARNING, diag::MAP_WARNING, "method %objcclass0 not found (return type defaults to 'id')", 0, true)
DIAG(warn_conflicting_param_types, CLASS_WARNING, diag::MAP_WARNING, "conflicting parameter types in implementation of %0: %1 vs %2", 0, true)
DIAG(warn_conflicting_ret_types, CLASS_WARNING, diag::MAP_WARNING, "conflicting return type in implementation of %0: %1 vs %2", 0, true)
DIAG(warn_conv_to_base_not_used, CLASS_WARNING, diag::MAP_WARNING, "conversion function converting %0 to its base class %1 will never be used", 0, true)
DIAG(warn_conv_to_self_not_used, CLASS_WARNING, diag::MAP_WARNING, "conversion function converting %0 to itself will never be used", 0, true)
DIAG(warn_conv_to_void_not_used, CLASS_WARNING, diag::MAP_WARNING, "conversion function converting %0 to %1 will never be used", 0, true)
DIAG(warn_decl_in_param_list, CLASS_WARNING, diag::MAP_WARNING, "declaration of %0 will not be visible outside of this function", 0, true)
DIAG(warn_delete_incomplete, CLASS_WARNING, diag::MAP_WARNING, "deleting pointer to incomplete type %0 may cause undefined behaviour", 0, true)
DIAG(warn_deprecated, CLASS_WARNING, diag::MAP_WARNING, "%0 is deprecated", "deprecated-declarations", true)
DIAG(warn_dup_category_def, CLASS_WARNING, diag::MAP_WARNING, "duplicate definition of category %1 on interface %0", 0, true)
DIAG(warn_duplicate_protocol_def, CLASS_WARNING, diag::MAP_WARNING, "duplicate protocol definition of %0 is ignored", 0, true)
DIAG(warn_empty_if_body, CLASS_WARNING, diag::MAP_WARNING, "if statement has empty body", "empty-body", true)
DIAG(warn_enum_too_large, CLASS_WARNING, diag::MAP_WARNING, "enumeration values exceed range of largest integer", 0, true)
DIAG(warn_enum_value_overflow, CLASS_WARNING, diag::MAP_WARNING, "overflow in enumeration value", 0, true)
DIAG(warn_exception_caught_by_earlier_handler, CLASS_WARNING, diag::MAP_WARNING, "exception of type %0 will be caught by earlier handler", 0, true)
DIAG(warn_excess_initializers, CLASS_EXTENSION, diag::MAP_WARNING, "excess elements in %select{array|vector|scalar|union|struct}0 initializer", 0, true)
DIAG(warn_excess_initializers_in_char_array_initializer, CLASS_EXTENSION, diag::MAP_WARNING, "excess elements in char array initializer", 0, true)
DIAG(warn_explicit_conversion_functions, CLASS_WARNING, diag::MAP_WARNING, "explicit conversion functions are a C++0x extension", 0, true)
DIAG(warn_extern_init, CLASS_WARNING, diag::MAP_WARNING, "'extern' variable has an initializer", 0, true)
DIAG(warn_falloff_nonvoid_function, CLASS_WARNING, diag::MAP_WARNING, "control reaches end of non-void function", "return-type", true)
DIAG(warn_falloff_noreturn_function, CLASS_WARNING, diag::MAP_ERROR, "function declared 'noreturn' should not return", "invalid-noreturn", true)
DIAG(warn_field_initialized, CLASS_WARNING, diag::MAP_IGNORE, "member '%0' will be initialized after", "reorder", true)
DIAG(warn_floatingpoint_eq, CLASS_WARNING, diag::MAP_IGNORE, "comparing floating point with == or != is unsafe", "float-equal", true)
DIAG(warn_gnu_inline_attribute_requires_inline, CLASS_WARNING, diag::MAP_WARNING, "'gnu_inline' attribute requires function to be marked 'inline', attribute ignored", 0, true)
DIAG(warn_illegal_constant_array_size, CLASS_EXTENSION, diag::MAP_IGNORE, "size of static array must be an integer constant expression", 0, true)
DIAG(warn_implements_nscopying, CLASS_WARNING, diag::MAP_WARNING, "default assign attribute on property %0 which implements NSCopying protocol is not appropriate with -fobjc-gc[-only]", 0, true)
DIAG(warn_implicit_function_decl, CLASS_WARNING, diag::MAP_IGNORE, "implicit declaration of function %0", "implicit-function-declaration", true)
DIAG(warn_incompatible_qualified_id, CLASS_WARNING, diag::MAP_WARNING, "incompatible type %2 %1, expected %0", 0, true)
DIAG(warn_incompatible_vectors, CLASS_WARNING, diag::MAP_IGNORE, "incompatible vector types %2 %1, expected %0", "vector-conversions", true)
DIAG(warn_incomplete_impl, CLASS_WARNING, diag::MAP_WARNING, "incomplete implementation", 0, true)
DIAG(warn_increment_bool, CLASS_WARNING, diag::MAP_WARNING, "incrementing expression of type bool is deprecated", 0, true)
DIAG(warn_initializer_overrides, CLASS_WARNING, diag::MAP_WARNING, "initializer overrides prior initialization of this subobject", 0, true)
DIAG(warn_initializer_string_for_char_array_too_long, CLASS_EXTENSION, diag::MAP_WARNING, "initializer-string for char array is too long", 0, true)
DIAG(warn_inst_method_not_found, CLASS_WARNING, diag::MAP_WARNING, "method %objcinstance0 not found (return type defaults to 'id')", 0, true)
DIAG(warn_invalid_asm_cast_lvalue, CLASS_WARNING, diag::MAP_WARNING, "invalid use of a cast in a inline asm context requiring an l-value: accepted due to -fheinous-gnu-extensions, but clang may remove support for this in the future", 0, true)
DIAG(warn_ivar_use_hidden, CLASS_WARNING, diag::MAP_WARNING, "local declaration of %0 hides instance variable", 0, true)
DIAG(warn_main_one_arg, CLASS_WARNING, diag::MAP_WARNING, "one-argument 'main' is usually a mistake", 0, true)
DIAG(warn_maybe_falloff_nonvoid_function, CLASS_WARNING, diag::MAP_WARNING, "control may reach end of non-void function", "return-type", true)
DIAG(warn_maynot_respond, CLASS_WARNING, diag::MAP_WARNING, "%0  may not respond to %1", 0, true)
DIAG(warn_missing_prototype, CLASS_WARNING, diag::MAP_IGNORE, "no previous prototype for function %0", "missing-prototypes", true)
DIAG(warn_missing_sentinel, CLASS_WARNING, diag::MAP_WARNING, "missing sentinel in %select{function call|method dispatch|block call}0", 0, true)
DIAG(warn_multiple_method_decl, CLASS_WARNING, diag::MAP_WARNING, "multiple methods named %0 found", 0, true)
DIAG(warn_noreturn_function_has_return_expr, CLASS_WARNING, diag::MAP_ERROR, "function %0 declared 'noreturn' should not return", "invalid-noreturn", true)
DIAG(warn_not_compound_assign, CLASS_WARNING, diag::MAP_WARNING, "use of unary operator that may be intended as compound assignment (%0=)", 0, true)
DIAG(warn_not_enough_argument, CLASS_WARNING, diag::MAP_WARNING, "not enough variable arguments in %0 declaration to fit a sentinel", 0, true)
DIAG(warn_ns_attribute_wrong_return_type, CLASS_WARNING, diag::MAP_WARNING, "%0 attribute only applies to functions or methods that return a pointer or Objective-C object", 0, true)
DIAG(warn_null_arg, CLASS_WARNING, diag::MAP_WARNING, "null passed to a callee which requires a non-null argument", "nonnull", true)
DIAG(warn_objc_property_attr_mutually_exclusive, CLASS_WARNING, diag::MAP_IGNORE, "property attributes '%0' and '%1' are mutually exclusive", "readonly-setter-attrs", true)
DIAG(warn_objc_property_copy_missing_on_block, CLASS_WARNING, diag::MAP_WARNING, "'copy' attribute must be specified for the block property when -fobjc-gc-only is specified", 0, true)
DIAG(warn_objc_property_default_assign_on_object, CLASS_WARNING, diag::MAP_WARNING, "default property attribute 'assign' not appropriate for non-gc object", 0, true)
DIAG(warn_objc_property_no_assignment_attribute, CLASS_WARNING, diag::MAP_WARNING, "no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed", 0, true)
DIAG(warn_offsetof_non_pod_type, CLASS_EXTENSION, diag::MAP_WARNING, "offset of on non-POD type %0", "invalid-offsetof", true)
DIAG(warn_partial_specs_not_deducible, CLASS_WARNING, diag::MAP_WARNING, "class template partial specialization contains %select{a template parameter|template parameters}0 that can not be deduced; this partial specialization will never be used", 0, true)
DIAG(warn_pragma_pack_invalid_alignment, CLASS_WARNING, diag::MAP_WARNING, "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'", 0, true)
DIAG(warn_pragma_pack_pop_failed, CLASS_WARNING, diag::MAP_WARNING, "#pragma pack(pop, ...) failed: %0", 0, true)
DIAG(warn_pragma_pack_pop_identifer_and_alignment, CLASS_WARNING, diag::MAP_WARNING, "specifying both a name and alignment to 'pop' is undefined", 0, true)
DIAG(warn_pragma_pack_show, CLASS_WARNING, diag::MAP_WARNING, "value of #pragma pack(show) == %0", 0, true)
DIAG(warn_pragma_unused_expected_localvar, CLASS_WARNING, diag::MAP_WARNING, "only local variables can be arguments to '#pragma unused'", 0, true)
DIAG(warn_pragma_unused_undeclared_var, CLASS_WARNING, diag::MAP_WARNING, "undeclared variable %0 used as an argument for '#pragma unused'", 0, true)
DIAG(warn_previous_alias_decl, CLASS_WARNING, diag::MAP_WARNING, "previously declared alias is ignored", 0, true)
DIAG(warn_printf_asterisk_precision_missing_arg, CLASS_WARNING, diag::MAP_WARNING, "'.*' specified field precision is missing a matching 'int' argument", 0, true)
DIAG(warn_printf_asterisk_precision_wrong_type, CLASS_WARNING, diag::MAP_WARNING, "field precision should have type 'int', but argument has type %0", "format", true)
DIAG(warn_printf_asterisk_width_missing_arg, CLASS_WARNING, diag::MAP_WARNING, "'*' specified field width is missing a matching 'int' argument", 0, true)
DIAG(warn_printf_asterisk_width_wrong_type, CLASS_WARNING, diag::MAP_WARNING, "field width should have type 'int', but argument has type %0", "format", true)
DIAG(warn_printf_empty_format_string, CLASS_WARNING, diag::MAP_WARNING, "format string is empty", "format-zero-length", true)
DIAG(warn_printf_format_string_contains_null_char, CLASS_WARNING, diag::MAP_WARNING, "format string contains '\\0' within the string body", "format", true)
DIAG(warn_printf_format_string_is_wide_literal, CLASS_WARNING, diag::MAP_WARNING, "format string should not be a wide string", "format", true)
DIAG(warn_printf_insufficient_data_args, CLASS_WARNING, diag::MAP_WARNING, "more '%%' conversions than data arguments", "format", true)
DIAG(warn_printf_invalid_conversion, CLASS_WARNING, diag::MAP_WARNING, "invalid conversion '%0'", "format", true)
DIAG(warn_printf_missing_format_string, CLASS_WARNING, diag::MAP_WARNING, "format string missing", "format", true)
DIAG(warn_printf_nonliteral, CLASS_WARNING, diag::MAP_IGNORE, "format string is not a string literal", "format-nonliteral", true)
DIAG(warn_printf_nonliteral_noargs, CLASS_WARNING, diag::MAP_WARNING, "format string is not a string literal (potentially insecure)", "format-security", true)
DIAG(warn_printf_too_many_data_args, CLASS_WARNING, diag::MAP_WARNING, "more data arguments than '%%' conversions", "format-extra-args", true)
DIAG(warn_printf_write_back, CLASS_WARNING, diag::MAP_WARNING, "use of '%%n' in format string discouraged (potentially insecure)", "format-security", true)
DIAG(warn_property_attr_mismatch, CLASS_WARNING, diag::MAP_WARNING, "property attribute in continuation class does not match the primary class", 0, true)
DIAG(warn_property_attribute, CLASS_WARNING, diag::MAP_WARNING, "property %0 '%1' attribute does not match the property inherited from %2", 0, true)
DIAG(warn_property_types_are_incompatible, CLASS_WARNING, diag::MAP_WARNING, "property type %0 is incompatible with type %1 inherited from %2", 0, true)
DIAG(warn_readonly_property, CLASS_WARNING, diag::MAP_WARNING, "attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1", 0, true)
DIAG(warn_receiver_forward_class, CLASS_WARNING, diag::MAP_WARNING, "receiver %0 is a forward class and corresponding @interface may not exist", 0, true)
DIAG(warn_redecl_library_builtin, CLASS_WARNING, diag::MAP_WARNING, "incompatible redeclaration of library function %0", 0, true)
DIAG(warn_redeclaration_without_attribute_prev_attribute_ignored, CLASS_WARNING, diag::MAP_WARNING, "'%0' redeclared without %1 attribute: previous %1 ignored", 0, true)
DIAG(warn_redefinition_of_typedef, CLASS_WARNING, diag::MAP_ERROR, "redefinition of typedef %0 is invalid in C", "typedef-redefinition", true)
DIAG(warn_ret_stack_addr, CLASS_WARNING, diag::MAP_WARNING, "address of stack memory associated with local variable %0 returned", 0, true)
DIAG(warn_ret_stack_ref, CLASS_WARNING, diag::MAP_WARNING, "reference to stack memory associated with local variable %0 returned", 0, true)
DIAG(warn_return_missing_expr, CLASS_WARNING, diag::MAP_WARNING, "non-void %select{function|method}1 %0 should return a value", "return-type", true)
DIAG(warn_root_inst_method_not_found, CLASS_WARNING, diag::MAP_WARNING, "instance method %0 is being used on 'Class' which is not in the root class", 0, true)
DIAG(warn_second_parameter_of_va_start_not_last_named_argument, CLASS_WARNING, diag::MAP_WARNING, "second parameter of 'va_start' not last named argument", 0, true)
DIAG(warn_selfcomparison, CLASS_WARNING, diag::MAP_WARNING, "self-comparison always results in a constant value", 0, true)
DIAG(warn_setter_getter_impl_required, CLASS_WARNING, diag::MAP_WARNING, "property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation", 0, true)
DIAG(warn_shift_gt_typewidth, CLASS_WARNING, diag::MAP_WARNING, "shift count >= width of type", 0, true)
DIAG(warn_shift_negative, CLASS_WARNING, diag::MAP_WARNING, "shift count is negative", 0, true)
DIAG(warn_stringcompare, CLASS_WARNING, diag::MAP_WARNING, "result of comparison against %select{a string literal|@encode}0 is unspecified (use strcmp instead)", 0, true)
DIAG(warn_struct_class_tag_mismatch, CLASS_WARNING, diag::MAP_IGNORE, "%select{struct|class}0 %select{|template}1 %2 was previously declared as a %select{class|struct}0 %select{|template}1", "mismatched-tags", true)
DIAG(warn_subobject_initializer_overrides, CLASS_WARNING, diag::MAP_WARNING, "subobject initialization overrides initialization of other fields within its enclosing subobject", 0, true)
DIAG(warn_suggest_noreturn_block, CLASS_WARNING, diag::MAP_IGNORE, "block could be attribute 'noreturn'", "missing-noreturn", true)
DIAG(warn_suggest_noreturn_function, CLASS_WARNING, diag::MAP_IGNORE, "function could be attribute 'noreturn'", "missing-noreturn", true)
DIAG(warn_tentative_incomplete_array, CLASS_WARNING, diag::MAP_WARNING, "tentative array definition assumed to have one element", 0, true)
DIAG(warn_transparent_union_attribute_field_size_align, CLASS_WARNING, diag::MAP_WARNING, "%select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored", 0, true)
DIAG(warn_transparent_union_attribute_floating, CLASS_WARNING, diag::MAP_WARNING, "first field of a transparent union cannot have floating point or vector type; transparent_union attribute ignored", 0, true)
DIAG(warn_transparent_union_attribute_not_definition, CLASS_WARNING, diag::MAP_WARNING, "transparent_union attribute can only be applied to a union definition; attribute ignored", 0, true)
DIAG(warn_transparent_union_attribute_zero_fields, CLASS_WARNING, diag::MAP_WARNING, "transparent union definition must contain at least one field; transparent_union attribute ignored", 0, true)
DIAG(warn_transparent_union_nonpointer, CLASS_WARNING, diag::MAP_WARNING, "'transparent_union' attribute support incomplete; only supported for pointer unions", 0, true)
DIAG(warn_typecheck_cond_incompatible_pointers, CLASS_EXTENSION, diag::MAP_WARNING, "pointer type mismatch (%0 and %1)", 0, true)
DIAG(warn_typecheck_cond_pointer_integer_mismatch, CLASS_EXTENSION, diag::MAP_WARNING, "pointer/integer type mismatch in conditional expression (%0 and %1)", 0, true)
DIAG(warn_typecheck_function_qualifiers, CLASS_WARNING, diag::MAP_WARNING, "qualifier on function type %0 has unspecified behavior", 0, true)
DIAG(warn_unavailable, CLASS_WARNING, diag::MAP_WARNING, "%0 is unavailable", "unavailable-declarations", true)
DIAG(warn_undeclared_selector, CLASS_WARNING, diag::MAP_IGNORE, "undeclared selector %0", "undeclared-selector", true)
DIAG(warn_undef_interface, CLASS_WARNING, diag::MAP_WARNING, "cannot find interface declaration for %0", 0, true)
DIAG(warn_undef_method_impl, CLASS_WARNING, diag::MAP_WARNING, "method definition for %0 not found", 0, true)
DIAG(warn_undef_protocolref, CLASS_WARNING, diag::MAP_WARNING, "cannot find protocol definition for %0", 0, true)
DIAG(warn_unused_expr, CLASS_WARNING, diag::MAP_WARNING, "expression result unused", "unused-value", true)
DIAG(warn_unused_parameter, CLASS_WARNING, diag::MAP_IGNORE, "unused parameter %0", "unused-parameter", true)
DIAG(warn_unused_property_expr, CLASS_WARNING, diag::MAP_WARNING, "property access result unused - getters should not have side effects", "unused-value", true)
DIAG(warn_unusual_main_decl, CLASS_WARNING, diag::MAP_WARNING, "'main' should not be declared %select{static|inline|static or inline}0", 0, true)
DIAG(warn_use_out_of_scope_declaration, CLASS_WARNING, diag::MAP_WARNING, "use of out-of-scope declaration of %0", 0, true)
DIAG(warn_value_always_false, CLASS_WARNING, diag::MAP_WARNING, "%0 is always false in this context", 0, true)
DIAG(warn_value_always_zero, CLASS_WARNING, diag::MAP_WARNING, "%0 is always zero in this context", 0, true)
DIAG(warn_weak_identifier_undeclared, CLASS_WARNING, diag::MAP_WARNING, "weak identifier %0 never declared", 0, true)
