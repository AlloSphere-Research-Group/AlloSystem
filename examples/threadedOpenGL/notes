
This is an attempt to test running an application in which the OS 'main' thread is not the principal thread used by the application itself. The motivation is for apps where timing is critical, in which the delays that can occur in the OS main thread are detrimental.
An interesting case is an OpenGL app; the rule is that all GL calls to a context must be single-threaded; but we can move this context to a different thread than the OS main thread.

We will create an app whose core logic runs in a secondary thread - call it the 'logic' thread. Messages from the OS main will need to be piped back and forth with the logic thread; we use the tube lock-free fifo to do this.



Cocoa notes:

NSThread detachNewThreadSelector: 
Detaches a new thread and uses the specified selector as the thread entry point.
Need to set up an autorelase pool for the thread, and destroy it at the end. 
This selector will be essentially a while(1) loop. 
http://developer.apple.com/mac/library/documentation/cocoa/reference/Foundation/Classes/NSThread_Class/Reference/Reference.html#//apple_ref/occ/clm/NSThread/detachNewThreadSelector:toTarget:withObject:

I guess the other way to do it would be to create a new runloop for the logic thread.
Some example code about half-way down here:
http://www.cocoadev.com/index.pl?RunLoop
I think both can be combined.

performSelectorOnMainThread (NSThread.h) allows a secondary thread to call functions in the main thread, and optionally wait for them. This would be e.g. the way to create a Window from within a script (because window creation must be in the OS thread?)
performSelector:onThread:withObject:waitUntilDone:
Similar, but we can target any NSThread with an active runloop. The runloop must have been started first.
http://developer.apple.com/mac/library/documentation/cocoa/conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1

Some good ideas (and super simple implementation) here:
http://forums.ps2dev.org/viewtopic.php?t=7303


OpenGL from a secondary thread

http://17.254.2.129/mac/library/documentation/GraphicsImaging/Conceptual/OpenGL-MacProgGuide/opengl_threading/opengl_threading.html
Summary:
Use only one thread per context.
Contexts that are on different threads can share object resources.
When you use an NSOpenGLView object with OpenGL calls that are issued from a thread other than the main one, you must set up mutex locking. Why? Unless you override the default behavior, the main thread may need to communicate with the view for such things as resizing.

context should be made current in the thread of choice; it should also be locked while being used (in case main thread tries to manipulate it, e.g. resizing?)